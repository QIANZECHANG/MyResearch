%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Journal Article
% LaTeX Template
% Version 1.4 (15/5/16)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com) with extensive modifications by
% Vel (vel@LaTeXTemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[twoside,twocolumn,a4j,dvipdfmx]{article}

%\usepackage{blindtext} % Package to generate dummy text throughout this template 

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage[english]{babel} % Language hyphenation and typographical rules

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text

\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
\renewcommand\thesubsection{\roman{subsection}} % roman numerals for subsections
\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
%\pagestyle{fancy} % All pages have headers and footers
%\fancyhead{} % Blank out the default header
%\fancyfoot{} % Blank out the default footer
%\fancyhead[C]{Running title $\bullet$ May 2016 $\bullet$ Vol. XXI, No. 1} % Custom header text
%\fancyfoot[RO,LE]{\thepage} % Custom footer text

\usepackage{titling} % Customizing the title section
\usepackage[dvipdfmx]{color}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric,arrows,positioning}
\usepackage{hyperref} % For hyperlinks in the PDF
\usepackage{color}
\usepackage{caption,subcaption}
\usepackage{amsmath}
\usepackage{multirow}

%--------------------------------------------
% code style
%---------------------------------------------
%\usepackage{lstlinebgrd}
\usepackage{xcolor}
\usepackage{listings}
\renewcommand\lstlistingname{Figure}
\renewcommand\lstlistlistingname{Figures}

% Color
\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}
\definecolor{Blue}{HTML}{2d5ae0}
\definecolor{Orange}{HTML}{e33900}
\definecolor{Green}{HTML}{009e73}
\definecolor{Purple}{HTML}{9400d3}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    frame=single,
    framexleftmargin=1em,
    %xleftmargin=0.5em,
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}

%----------------------------------------------
%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\setlength{\droptitle}{-4\baselineskip} % Move the title up

\pretitle{\begin{center}\Huge\bfseries} % Article title formatting
\posttitle{\end{center}} % Article title closing formatting
\title{Automated Memory Error Repair Based on Hybrid Program Analysis} % Article title
\author{ ZECHANG QIAN \\ (Supervisor:  Katsuhiko Gondow)}
%\textsc{John Smith}\thanks{A thank you or further information} \\[1ex] % Your name
%\normalsize University of California \\ % Your institution
%\normalsize \href{mailto:john@smith.com}{john@smith.com} % Your email address
%\and % Uncomment if 2 authors are required, duplicate these 4 lines if more
%\textsc{Jane Smith}\thanks{Corresponding author} \\[1ex] % Second author's name
%\normalsize University of Utah \\ % Second author's institution
%\normalsize \href{mailto:jane@smith.com}{jane@smith.com} % Second author's email address

\date{} % Leave empty to omit a date
\renewcommand{\maketitlehookd}{%
\begin{abstract}
\textcolor{red}{
Automated program repair is a technology which aims to fix program errors and vulnerabilities automatically. In the field of memory error repair, with the development of bug detection tools, we can easily detect memory errors in programs. However, fixing those errors is time-consuming and error-prone. Because the program’s heap-related behavior plays a critical role in memory error repair, the existing techniques are mainly based on static analysis, where the static bug-finder is used to detect program memory errors and then repair tools collect the essential information via static analysis. But since static bug-finder may give wrong alarms which will affect the performance of the repair tools, and static analysis often requires high overhead. }

\textcolor{red}{
We present \textbf{HAMER}, a hybrid automatic memory error repair tool that aims to address those 
shortcomings by using hybrid analysis. HAMER first uses fuzzer to check the alarms given by the static 
bug-finder and extracts the real errors from those alarms. Then it tries to fix those errors by using 
hybrid analysis.}
\end{abstract}
}

%----------------------------------------------------------------------------------------

\begin{document}

% Print the title
\maketitle

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\section{Introduction}
\textcolor{red}{
Memory errors, such as memory leaks, can have catastrophic effects,  thus detecting and fixing them has always been a critical task for developers. Memory error detection performance is improving with the development of memory error detection technologies, however resolving these problems takes a lot of time and work for developers, and erroneous patches might lead to more significant effects.}

\textcolor{red}{
Existing memory error repair techniques\cite{SAVER,Memfix} are mainly based on static analysis. This is because resolving issues like memory leaks necessitates an understanding of heap-related behavior, such as error source and sink. On the other hand, static analysis techniques might have a high time and space overhead, and they aren't always particularly good at dealing with problems such as indirect calls and alias. While dynamic analysis can help with these issues, it does not provide enough information to generate patches.}

\textcolor{red}{
In this paper, we present \textbf{HAMER}, a hybrid analysis-based memory error repair \mbox{technique}. We use a static bug-finder to detect the program first, then use a fuzzer to detect the alarms and extract the real bugs. After that, we collect program variables that can be utilized to synthesize patches by variable dependency analysis. We also gather the test cases generated by the fuzzer which trigger or do not trigger the errors and then use the component-based program synthesis technique to try to generate patches from these variables and test cases. Finally, We utilize a fuzzer to detect the current fixed program, and if the repair is erroneous, we collect the test case that triggers the errors and repeat our repair method until the error is resolved or timeout. This strategy ensures that the patches generated by HAMER can repair current errors while without introducing new ones.}

\textcolor{red}{
\textbf{Contributions.} This paper makes the following contributions:
\begin{itemize}
  \item We present a new technique for repairing memory errors based on hybrid analysis.
  \item We present HAMER~\footnote{https://github.com/QIANZECHANG/MyResearch(仮)}, a memory error repair tool that implements the proposed approach.
\end{itemize}
}

%------------------------------------------------
%	Overview
%----------------------------------------------------------------------------------------

\section{Overview}
%----------------pipeline-----------------------------------
\tikzstyle{tool} = [diamond, draw, fill=green!20, text centered, text width=4.5em, aspect=2]
\tikzstyle{block} = [rectangle, draw, fill=blue!20, text width=7em, rounded corners, minimum height=3em]
\tikzstyle{bigblock} = [rectangle, draw, fill=blue!20, text width=9em, rounded corners, minimum height=3em]
\tikzstyle{line} = [thick,->,>=stealth]
\tikzstyle{outdata} = [rectangle, draw, fill=brown!20, text width=5em, minimum height=3em]
\tikzstyle{code} = [draw, ellipse,fill=red!20, text width=2em, minimum height=3em]
\tikzstyle{bigcode} = [draw, ellipse,fill=red!20, text width=5.5em, minimum height=3em]
\begin{figure*}[ht]
\begin{tikzpicture}[node distance = 3.5cm, on grid]
  %node
  \node[tool] (infer){Infer};
  \node[code, below of=infer,yshift=1.5cm] (src){src.c};
  \node[outdata, right of=infer] (efunc){error\\functions};
  \node[tool, right of=src] (fuzzer1){LibFuzzer};
  \node[outdata, below of=fuzzer1, yshift=1.5cm] (error){true errors};
  \node[block, below of=error,yshift=2cm] (dep){Dependency\\Collection};
  \node[outdata, right of=dep] (depvar){dependent\\variables};
  \node[block, right of=error,yshift=1cm] (inst){Source\\Instrumentation};
  \node[bigcode, right of=fuzzer1,yshift=1cm] (instcode){Instrumented\\code};
  \node[tool, right of=instcode] (fuzzer2){LibFuzzer};
  \node[outdata, right of=inst] (test){test suite};
  \node[bigblock, right of=depvar] (syn){Component-based\\Program Synthesis};
  \node[bigcode, right of=syn] (fix){current\\fixed code};
  \node[code, above of=fuzzer2,yshift=-1.5cm] (output){out.c};
  \node[right of=output,yshift=-1cm,xshift=-2.5cm] (no){no error}; 
  \node[below of=no,yshift=1.5cm,xshift=-0.3cm] (yes){error}; 
 %edge
  \draw [line] (src) -- (infer);
  \draw [line] (src) -- (fuzzer1);
  \draw [line] (infer) -- (efunc);
  \draw [line] (efunc) -- (fuzzer1);
  \draw [line] (fuzzer1) -- (error);
  \draw [line] (error) -- (dep);
  \draw [line] (src) |- (dep);
  \draw [line] (dep) -- (depvar);
  \draw [line] (depvar) -- (inst);
  \draw [line] (inst) -- (instcode);
  \draw [line] (instcode) -- (fuzzer2);
  \draw [line] (fuzzer2) -- (test);
  \draw [line] (test) -- (syn);
  \draw [line] (depvar) -- (syn);
  \draw [line] (syn) -- (fix);
  \draw [line] (fix) |- (fuzzer2);
  \draw [line] (fuzzer2) -- (output);
  \draw [line] (src) |- (inst);
\end{tikzpicture}
  \caption{HAMER pipeline}
  \label{pipeline}
\end{figure*}
%----------------code---------------------------
\lstset{
  style=CStyle,
  moredelim=[is][\color{Blue}\bfseries]{<\#blue\#}{\#>},
  moredelim=[is][\color{Orange}\bfseries]{<\#orange\#}{\#>},
  moredelim=[is][\color{Green}\bfseries]{<\#green\#}{\#>},
  moredelim=[is][\color{Purple}\bfseries]{<\#purple\#}{\#>},
}

\begin{figure*}
  \begin{subfigure}{0.47\textwidth}
    \lstinputlisting{src.c}
    \caption{o0, o1, o2 occur memory leak}
    \label{me1a}
  \end{subfigure}\hfill
  \begin{subfigure}{0.45\textwidth}
    \lstinputlisting[firstline=17,firstnumber=17]{result_src.c}
    \caption{HAMER-generated patch}
    \label{me1b}
  \end{subfigure}
  \caption{Motivating Example 1: Infer false-negative alarm} 
  \label{me1}
\end{figure*}

\begin{figure*}
  \begin{subfigure}{0.47\textwidth}
    \lstinputlisting{saver.c}
    \caption{No memory leak}
  \end{subfigure}\hfill
  \begin{subfigure}{0.45\textwidth}
    \lstinputlisting{saver_result.c}
    \caption{SAVER-generated patch}
  \end{subfigure}
  \caption{Motivating Example 2: Infer false-positive alarm}
  \label{me2}
\end{figure*}

\textcolor{red}{
We illustrate key features of HAMER and how it works. Figure~\ref{pipeline} depicts a high-level overview of the HAMER pipeline. First, we check the program with the static analyzer \mbox{Infer}~\footnote{https://fbinfer.com/}, and then we manually collect the functions that contain Infer alerts. Following that, these functions are fuzzed by LibFuzzer~\footnote{https://llvm.org/docs/LibFuzzer.html} to detect true errors.  For those functions on the error path, we collect the variables that are dependent on the function arguments and stub them, and then we collect the tests that do or do not trigger the error by LibFuzzer. Finally, we use component-based program synthesis to generate patches. Because the quality of the test suite affects the quality of the patch, we use LibFuzzer to check the current fixed code again, and if it hasn't been fixed or if a new error occurs, we collect the tests that cause the error or insert the patch in a different location. This strategy ensures that the patches generated by HAMER are correct and do not introduce new errors. In the following paragraphs of this section, we will use two motivating examples to demonstrate the workflow and characteristics of HAMER.}

\subsection{Motivating Example 1}
\textcolor{red}{
This buggy code has three memory leaks, denoted by {\it o0}, {\it o1}, and {\it o2}, as shown in Figure~\ref{me1a}. First, we use infer to detect this code, obtaining the following result:}

\begin{minipage}{\textwidth}
\vspace{0.2cm}
\hspace{-0.45cm}
\raggedright
\textsl{Object allocated at line 20 is unreachable at line 20.}
\vspace{0.2cm}
\end{minipage}

\textcolor{red}{
Because static analyzers like Infer have a difficult time resolving issues like indirect calls, they can only detect the memory leak of {\it o2}. After we received the Infer results, the error function was detected again by LibFuzzer, and all errors were successfully detected. For example, for {\it o1}, we can get the fuzzing result shown below:
}
\begin{minipage}{\textwidth}
    \vspace{0.2cm}
    \textsl{\hspace{0.3cm}in malloc (../a.out+0x52204d)\\\hspace{0.3cm}in new\_node2 ../src.c:12:18\\\hspace{0.3cm}in func ../src.c:23:7}
    \vspace{0.2cm}
\end{minipage}

\textcolor{red}{
We can get all of the functions on the error path using LibFuzzer. Obviously, the correct fix location could be in any of the functions, so we collect the variables that are dependent on the function argument, and we also collect both the heap object information and the return location of each function during this static analysis. }

\begin{table}[h]
  \caption{Instrumentation result of o1}
  \label{instres}
  \centering
  \begin{tabular}{|c|c|c|c|}
    \hline
    func  & \multicolumn{2}{|c|}{new\_node2} & \multirow{2}{*}{error} \\
    \cline{1-3}
    a & a & n->v &\\
    \hline
     0 & 0  & 0 & 1\\
     5 & 5  & 25 & 0\\
     6 & 6  & 36 & 0\\
     8 & 8  & 64 & 0\\
    \hline
  \end{tabular}
\end{table}

\textcolor{red}{
Following that, we instrument all of the dependent variables and run the source instrumented code through Libfuzzer to collect dynamic values for each dependent variable. Table~\ref{instres} displays the results of o1's collection. The {\it error} column indicates whether or not an error occurred at the current value, with 1 indicating that it did and 0 indicating that it did not. Table~\ref{instres} shows that {\it o1} leaks when the variable {\it a} in the function {\it func} is less than or equal to 4. We can synthesize the ideal patch using component-based program synthesis\cite{oracle}, which is:
}
\begin{minipage}{\textwidth}
\vspace{0.2cm}
\hspace{0.3cm}
\raggedright
\verb|if(a<=4)free(x);|
\label{patch1}
\vspace{0.2cm}
\end{minipage}

\textcolor{red}{
Finally, we use LibFuzzer to detect the patched code, and if it fixes the current bug, we keep the patch and fix other bugs until all bugs are fixed or time out. If the current patch does not fix the bug or causes a new bug, we try to insert the patch into another location or collect new tests to synthesize a new patch. For example, we can also synthesize patches like {\it if(a<=3)free(x);} using the Table~\ref{instres} results. With Libfuzzer, we can see that when {\it a=4}, {\it o1} still occurs memory leak. We will start by trying alternative fix locations, however, because the function {\it func} only has one return place, we can only collect new tests to synthesize a new patch. We add {\it (a:4, error:1)} to the test suite and then use the synthesizer to generate a new patch. It's self-evident that the improved test suite enabled us to obtain the correct patch. We will utilize temporary variables to save the heap object and variables in the conditional when we apply the patch. This step is necessary to prevent these variables from changing between the allocation location and patch insertion location.
}

\textcolor{red}{
Although it is possible to fix the  {\it o1} memory leak by inserting a patch into function  {\it new\_node2}, the use-after-free problem will occur if the memory is freed too early due to the use of  {\it x->v} at line 25 of the function  {\it func}.
}


%---------------------------------------------
%[+] { Insert: if (true) free(*(func:x.p2)) at 3 (line 12, column 3) }
% memory dynamically allocated to `y` by call to `malloc()` at line 20, column 11 is not reachable after line 20, column 3.

%------------------------------------------------------
\subsection{Motivating Example 2}
\textcolor{red}{
We briefly discussed how HAMER uses fuzzing (LibFuzzer) to detect and fix errors that are not noticed by the static analyzer (Infer) in Motivating Example 1. Similarly, HAMER can avoid attempting to resolve false alarms. In Motivating Example 2, line 10 frees {\it o1} in some other way, but Infer misses it, so it assumes {\it o1} occurs memory leak. SAVER~\cite{SAVER} also ignores the fact that this is a false alarm and generates the incorrect patch, resulting in {\it double-free}. HAMER utilizes LibFuzzer to dynamically detect code, and LibFuzzer does not report issues for Motivating Example 2, therefore HAMER saves time trying to generate a fix for the wrong alarm.
}
%---------------------------------------------------------------------------------------
%	Approach
%----------------------------------------------------------------------------------------
\section{Approach}
\textcolor{red}{
In this section, we describe our approach in detail, explaining what technical issues arise and how we address them. There are three major issues to consider:
\begin{itemize}
\item It is difficult for LibFuzzer to directly collect enough test suites to synthesize the correct patches. How can HAMER generate the correct patches?
\item How does HAMER choose the correct fix location(s) when a function has multiple return places?
\item How does HAMER deal with several memory errors in a single function?
\end{itemize}
}

\textcolor{red}{
HAMER will solve these issues by using LibFuzzer to constantly check the patched code. In subsection~\ref{repair}, we will go over our repair algorithm in detail. Until then, we will describe how HAMER gathers the data required to resolve the errors.
}
\subsection{Error Detection}
\textcolor{red}{
HAMER uses a static analyzer to find functions that may have memory errors and then uses fuzzer to detect the real errors in those functions. The purpose of applying the static analyzer is to improve HAMER's scalability, as the fuzzer always takes a long time to detect errors. Using the static analyzer to pick out candidate functions prevents fuzzer from wasting time in locations where it is not necessary. But obviously, HAMER will not be able to fix errors in functions that are not provided by the static analyzer. So for short code, we can just simply use fuzzer to detect errors.
}



\subsection{Dependency Collection}
\subsection{Source Instrumentation}
\subsection{Component-based Program Synthesis}
\subsection{Repair Algorithm}
\label{repair}



%----------------------------------------------------------------------------------------
%	Evaluation
%----------------------------------------------------------------------------------------
\section{Evaluation}

%---------------------------------------------------------------------------------------
%      Related work
%----------------------------------------------------------------------------------------
\section{Related Work}


%---------------------------------------------------------------------------------------
%      Conclusion	
%----------------------------------------------------------------------------------------
\section{Conclusion}


%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------

\def\newblock{\hskip .11em plus .33em minus .07em}
\bibliographystyle{plain}
\bibliography{mybib}

%----------------------------------------------------------------------------------------

\end{document}
