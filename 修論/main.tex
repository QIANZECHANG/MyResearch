%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Journal Article
% LaTeX Template
% Version 1.4 (15/5/16)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com) with extensive modifications by
% Vel (vel@LaTeXTemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

%\documentclass[twoside,twocolumn,a4j,dvipdfmx]{article}
\documentclass[a4j,dvipdfmx]{article}
%\usepackage{blindtext} % Package to generate dummy text throughout this template 

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage[english]{babel} % Language hyphenation and typographical rules

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text

\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
\renewcommand\thesubsection{\roman{subsection}} % roman numerals for subsections
\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
%\pagestyle{fancy} % All pages have headers and footers
%\fancyhead{} % Blank out the default header
%\fancyfoot{} % Blank out the default footer
%\fancyhead[C]{Running title $\bullet$ May 2016 $\bullet$ Vol. XXI, No. 1} % Custom header text
%\fancyfoot[RO,LE]{\thepage} % Custom footer text

\usepackage{titling} % Customizing the title section
\usepackage[dvipdfmx]{color}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric,arrows,positioning}
\usepackage{hyperref} % For hyperlinks in the PDF
\usepackage{color}
\usepackage{caption,subcaption}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{mathtools}
\usepackage{algorithm,algorithmic}
\usepackage{amssymb}

%--------------------------------------------
% code style
%---------------------------------------------
%\usepackage{lstlinebgrd}
\usepackage{xcolor}
\usepackage{listings}
\renewcommand\lstlistingname{Figure}
\renewcommand\lstlistlistingname{Figures}

% Color
\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}
\definecolor{Blue}{HTML}{2d5ae0}
\definecolor{Orange}{HTML}{e33900}
\definecolor{Green}{HTML}{009e73}
\definecolor{Purple}{HTML}{9400d3}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    frame=single,
    framexleftmargin=1em,
    %xleftmargin=0.5em,
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}

%----------------------------------------------
%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\setlength{\droptitle}{-4\baselineskip} % Move the title up

\pretitle{\begin{center}\Huge\bfseries} % Article title formatting
\posttitle{\end{center}} % Article title closing formatting
\title{Automated Memory Error Repair Based on Hybrid Program Analysis} % Article title
\author{ ZECHANG QIAN \\ (Supervisor:  Katsuhiko Gondow)}
%\textsc{John Smith}\thanks{A thank you or further information} \\[1ex] % Your name
%\normalsize University of California \\ % Your institution
%\normalsize \href{mailto:john@smith.com}{john@smith.com} % Your email address
%\and % Uncomment if 2 authors are required, duplicate these 4 lines if more
%\textsc{Jane Smith}\thanks{Corresponding author} \\[1ex] % Second author's name
%\normalsize University of Utah \\ % Second author's institution
%\normalsize \href{mailto:jane@smith.com}{jane@smith.com} % Second author's email address

\date{} % Leave empty to omit a date
\renewcommand{\maketitlehookd}{%
\begin{abstract}
Automated program repair is a technology which aims to fix program errors and vulnerabilities automatically. In the field of memory error repair, with the development of bug detection tools, we can easily detect memory errors in programs. However, fixing those errors is time-consuming and error-prone. Because the programâ€™s heap-related behavior plays a critical role in memory error repair, the existing techniques are mainly based on static analysis, where the static analyzer is used to detect program memory errors and then repair tools collect the essential information via static analysis. But since static analyzer may give wrong alarms which will affect the performance of the repair tools, and static analysis often requires high overhead. 

We present \textbf{HAMER}, a hybrid automated memory error repair tool that aims to address those 
shortcomings by using hybrid analysis. HAMER first uses fuzzer to check the alarms given by the static 
analyzer and extracts the real errors from those alarms. Then it tries to fix those errors by using 
hybrid analysis. \textcolor{blue}{HAMER is the first automated memory error repair technique based on fuzzing results. HAMER does not waste time resolving alarms that are incorrect because the errors reported by fuzzer are real errors, and HAMER also utilizes fuzzer to test the generated patches to ensure they are correct. For the necessary information for synthesizing patches, HAMER uses lightweight static analysis techniques to collect it.} \textcolor{red}{evaluation and conclusion}
\end{abstract}
}

%----------------------------------------------------------------------------------------

\begin{document}

% Print the title
\maketitle

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\section{Introduction}
Memory errors, such as memory leaks, can have catastrophic effects,  thus detecting and fixing them has always been a critical task for developers. Memory error detection performance is improving with the development of memory error detection technologies, however resolving these problems takes a lot of time and work for developers, and erroneous patches might lead to more significant effects.

Existing memory error repair techniques~\cite{SAVER,Memfix} are mainly based on static analysis. This is because resolving issues like memory leaks necessitates an understanding of heap-related behavior, such as error source and sink. \textcolor{blue}{Collecting heap-related behavior information needs a high time and space overhead. Because wrong patches or fixing locations might lead to more significant errors, and different heap objects can interact with each other, all of this must be fully considered when generating patches. The state-of-the-art automated memory error repair technology SAVER~\cite{SAVER} saves these heap-related behaviors by constructing an object flow graph, which has high time and space complexity. However, because static analysis techniques are not good at dealing with problems such as indirect calls and alias, the repair tools which based on static analysis might generate the wrong patches.} While dynamic analysis can help with these issues, it does not provide enough information to generate patches.

In this paper, we present \textbf{HAMER}, a hybrid analysis-based memory error repair \mbox{technique}. We use a static analyzer to detect the program first, then use a fuzzer to detect the alarms and extract the real errors. \textcolor{blue}{Fuzzer triggers runtime errors, thus it will not give false-positive alarms, allowing HAMER to avoid fixing wrong alarms.} After that, we collect program variables that can be utilized to synthesize patches by variable dependency analysis. \textcolor{blue}{During this procedure, we also collect the return locations of each function as the candidate fix locations. With this lightweight static analysis, HAMER is able to obtain enough information to fix the buggy program.} We then gather the test cases generated by the fuzzer which trigger or do not trigger the errors and use the component-based program synthesis~\cite{oracle} to try to generate patches from these variables and test cases. Finally, we utilize the fuzzer to detect the current fixed program, and if the repair is erroneous, we collect the test case that triggers the errors and repeat our repair method until the error is resolved or timeout. This strategy ensures that the patches generated by HAMER can repair current errors while without introducing new ones. \textcolor{red}{evaluation and conclusion}

\textbf{Contributions.} This paper makes the following contributions:
\begin{itemize}
  \item We present a new technique for repairing memory errors based on hybrid analysis. \textcolor{blue}{Our approach collects the relevant information using a lightweight static analysis, then repeatedly synthesize the patch and test it with fuzzer.}
  \item We present HAMER~\footnote{https://github.com/QIANZECHANG/MyResearch(ä»®)}, a memory error repair tool that implements the proposed approach.
\end{itemize}

%------------------------------------------------
%Backgroud
%----------------------------------------------------------------------------------------
\section{Background}
\textcolor{red}{
HAMER detects bugs using existing bug detection tools. In this section, we will introduce the static analyzer (Infer~\footnote{https://fbinfer.com/}) and fuzzer (LibFuzzer~\footnote{https://llvm.org/docs/LibFuzzer.html}) that HAMER uses.
}
\subsection{Infer}
\textcolor{red}{
Infer is a static program analyzer for Java, C, and Objective-C, written in OCaml, developed by Facebook. At present Infer is tracking problems caused by null pointer dereferences and resource and memory leaks, which cause some of the more important problems. Infer is a high-performance static analyzer with high scalability and efficiency, and it is widely used by programmers and researchers. However, like other static analyzers, Infer is hard to handle some issues, such as indirect call and alias, which causes Infer to provide false-negative and false-positive alarms. As a result of this shortcoming, automated repair tools may waste time on the wrong alarms (false-positive) and have no way to fix the errors that are not discovered (false-negative).
}

\subsection{LibFuzzer}
\textcolor{red}{
LibFuzzer is an in-process, coverage-guided, evolutionary fuzzing engine. LibFuzzer is linked with the library under test, and feeds fuzzed inputs to the library via a specific fuzzing entry point (target function); the fuzzer then tracks which areas of the code are reached, and generates mutations on the corpus of input data in order to maximize the code coverage. The code coverage information for libFuzzer is provided by LLVMâ€™s SanitizerCoverage~\footnote{https://clang.llvm.org/docs/SanitizerCoverage.html} instrumentation.
}	

\textcolor{red}{
LibFuzzer uses the information provided by the AddressSanitizer~\footnote{https://clang.llvm.org/docs/AddressSanitizer.html} to determine if an error has happened within the detected code coverage when detecting memory errors. When the program allocates memory, the allocated space is marked, and the behavior is verified for legality each time the space is accessed. These memory spaces are checked at the end of the program to see if they have been freed.
}

\textcolor{red}{
Because LibFuzzer can only fuzz test one function argument at a time, we must test each argument independently for functions with multiple arguments. LibFuzzer may fail to mutate the inputs that go into all paths for some functions with complex input. Furthermore, LibFuzzer will stop and report errors anytime it triggers the error, thus if a function has several errors, LibFuzzer cannot ensure that all of them will be detected at the same time. The code below, for example, has two memory leaks. 
}

\begin{minipage}{\textwidth}
    \vspace{0.2cm}
    \textsl{\hspace{0.3cm}p1 = malloc(1);\\\hspace{0.3cm}if (a == 5) p2 = malloc(1);\\}
\end{minipage}
\textcolor{red}{
The ideal situation would be for LibFuzzer to input {\it a=5} and trigger both errors. But in most cases,  LibFuzzer inputs other values only triggers the memory leak of {\it p1} and then exits. As a result, LibFuzzer may not be able to detect all of the errors in a function at the same time (although it has the ability to do).
}


%------------------------------------------------
%	Overview
%----------------------------------------------------------------------------------------
\section{Overview}

We illustrate key features of HAMER and how it works. Figure~\ref{pipeline} depicts a high-level overview of the HAMER pipeline.

First, we check the program with the static analyzer \mbox{Infer}, and then we manually collect the functions that contain Infer alarms. Following that, these functions are fuzzed by LibFuzzer to detect true errors.  For those functions on the error path, we collect the variables that are dependent on the function arguments and stub them. \textcolor{blue}{Dependent variables will be used to synthesize the conditional of the patch. After that, we instrument all of the dependent variables and run the program via LibFuzzer to collect the tests that do or do not trigger the error.} Finally, we use \textcolor{blue}{a simplified component-based program synthesis (simp-CBPS)} to generate patches. Because the quality of the test suite affects the quality of the patch, we use LibFuzzer to check the current fixed code again, and if it has not been fixed or if a new error occurs, we collect the tests that cause the error or insert the patch in a different location. This strategy ensures that the patches generated by HAMER are correct and do not introduce new errors. In the following paragraphs of this section, we will use two motivating examples to demonstrate the workflow and characteristics of HAMER.

%----------------pipeline-----------------------------------
\tikzstyle{tool} = [diamond, draw, fill=green!20, text centered, text width=4.5em, aspect=2]
\tikzstyle{block} = [rectangle, draw, fill=blue!20, text width=7em, rounded corners, minimum height=3em]
\tikzstyle{block2} = [rectangle, draw, fill=blue!20, text centered, text width=7em, rounded corners, minimum height=3em]
\tikzstyle{line} = [thick,->,>=stealth]
\tikzstyle{outdata} = [rectangle, draw, fill=brown!20, text width=5em, minimum height=3em]
\tikzstyle{code} = [draw, ellipse,fill=red!20, text width=2em, minimum height=3em]
\tikzstyle{bigcode} = [draw, ellipse,fill=red!20, text width=5.5em, minimum height=3em]
\begin{figure*}[ht]
\hspace{-0.5cm}
\begin{tikzpicture}[node distance = 3.5cm, on grid]
  %node
  \node[tool] (infer){Infer};
  \node[code, below of=infer,yshift=1.5cm] (src){src.c};
  \node[outdata, right of=infer] (efunc){error\\functions};
  \node[tool, right of=src] (fuzzer1){LibFuzzer};
  \node[outdata, below of=fuzzer1, yshift=1.5cm] (error){true errors};
  \node[block, below of=error,yshift=2cm] (dep){Dependency\\Collection};
  \node[outdata, right of=dep] (depvar){dependent\\variables};
  \node[block, right of=error,yshift=1cm] (inst){Source\\Instrumentation};
  \node[bigcode, right of=fuzzer1,yshift=1cm] (instcode){Instrumented\\code};
  \node[tool, right of=instcode] (fuzzer2){LibFuzzer};
  \node[outdata, right of=inst] (test){test suite};
  \node[block2, right of=depvar] (syn){simp-CBPS};
  \node[bigcode, right of=syn] (fix){current\\fixed code};
  \node[code, above of=fuzzer2,yshift=-1.5cm] (output){out.c};
  \node[right of=output,yshift=-1cm,xshift=-2.5cm] (no){no error}; 
  \node[below of=no,yshift=1.5cm,xshift=-0.3cm] (yes){error}; 
 %edge
  \draw [line] (src) -- (infer);
  \draw [line] (src) -- (fuzzer1);
  \draw [line] (infer) -- (efunc);
  \draw [line] (efunc) -- (fuzzer1);
  \draw [line] (fuzzer1) -- (error);
  \draw [line] (error) -- (dep);
  \draw [line] (src) |- (dep);
  \draw [line] (dep) -- (depvar);
  \draw [line] (depvar) -- (inst);
  \draw [line] (inst) -- (instcode);
  \draw [line] (instcode) -- (fuzzer2);
  \draw [line] (fuzzer2) -- (test);
  \draw [line] (test) -- (syn);
  \draw [line] (depvar) -- (syn);
  \draw [line] (syn) -- (fix);
  \draw [line] (fix) |- (fuzzer2);
  \draw [line] (fuzzer2) -- (output);
  \draw [line] (src) |- (inst);
\end{tikzpicture}
  \caption{HAMER pipeline}
  \label{pipeline}
\end{figure*}
%----------------code---------------------------
\lstset{
  style=CStyle,
  moredelim=[is][\color{Blue}\bfseries]{<\#blue\#}{\#>},
  moredelim=[is][\color{Orange}\bfseries]{<\#orange\#}{\#>},
  moredelim=[is][\color{Green}\bfseries]{<\#green\#}{\#>},
  moredelim=[is][\color{Purple}\bfseries]{<\#purple\#}{\#>},
}

\begin{figure*}
  \begin{subfigure}{0.47\textwidth}
    \lstinputlisting{src.c}
    \caption{o0, o1, o2 occur memory leak}
    \label{me1a}
  \end{subfigure}\hfill
  \begin{subfigure}{0.45\textwidth}
    \lstinputlisting[firstline=17,firstnumber=17]{result_src.c}
    \caption{HAMER-generated patch}
    \label{me1b}
  \end{subfigure}
  \caption{Motivating Example 1: Infer false-negative alarm} 
  \label{me1}
\end{figure*}

\begin{figure*}
  \begin{subfigure}{0.47\textwidth}
    \lstinputlisting{saver.c}
    \caption{No memory leak}
  \end{subfigure}\hfill
  \begin{subfigure}{0.45\textwidth}
    \lstinputlisting{saver_result.c}
    \caption{SAVER-generated patch}
  \end{subfigure}
  \caption{Motivating Example 2: Infer false-positive alarm}
  \label{me2}
\end{figure*}

\subsection{Motivating Example 1}
This buggy code has three memory leaks, denoted by {\it o0}, {\it o1}, and {\it o2}, as shown in Figure~\ref{me1a}. First, we use Infer to detect this code, obtaining the following result:

\begin{minipage}{\textwidth}
\vspace{0.2cm}
\textsl{\hspace{0.3cm}Object allocated at line 20 is unreachable at line 20.\\}
\end{minipage}

Because static analyzers like Infer have a difficult time resolving issues like indirect calls, they can only detect the memory leak of {\it o2}. After we received the Infer results, the error function was detected again by LibFuzzer, and all errors were successfully detected. For example, for {\it o1}, we can get the fuzzing result shown below:


\begin{minipage}{\textwidth}
    \vspace{0.2cm}
    \textsl{\hspace{0.3cm}in malloc ../a.out\\\hspace{0.3cm}in new\_node2 ../src.c:12:18\\\hspace{0.3cm}in func ../src.c:23:7\\}
\end{minipage}

We can get all of the functions on the error path using LibFuzzer. Obviously, the correct fix location could be in any of the functions, so we collect the variables that are dependent on the function argument, and we also collect both the heap object information and the return location of each function during this static analysis. 

\begin{table}[h]
  \caption{Instrumentation result of o1}
  \label{instres}
  \centering
  \begin{tabular}{|c|c|c|c|}
    \hline
    func  & \multicolumn{2}{|c|}{new\_node2} & \multirow{2}{*}{error} \\
    \cline{1-3}
    a & a & n->v &\\
    \hline
     0 & 0  & 0 & 1\\
     5 & 5  & 25 & 0\\
     6 & 6  & 36 & 0\\
     8 & 8  & 64 & 0\\
    \hline
  \end{tabular}
\end{table}

Following that, we instrument all of the dependent variables and run the source instrumented code through Libfuzzer to collect dynamic values for each dependent variable. Table~\ref{instres} displays the results of o1's collection. The {\it error} column indicates whether or not \textcolor{blue}{memory leak} occurred at the current value, with 1 indicating that it did and 0 indicating that it did not. Table~\ref{instres} shows that {\it o1} leaks when the variable {\it a} in the function {\it func} is less than or equal to 4. We can synthesize the ideal patch using simp-CBPS, which is:

\begin{minipage}{\textwidth}
\vspace{0.2cm}
\hspace{0.3cm}
\raggedright
\verb|if(a<=4)free(o1);|
\label{patch1}
\vspace{0.2cm}
\end{minipage}

Finally, we use LibFuzzer to detect the patched code, and if it fixes the current bug, we keep the patch and fix other bugs until all bugs are fixed or time out. If the current patch does not fix the bug or causes a new bug, we try to insert the patch into another location or collect new tests to synthesize a new patch. For example, we can also synthesize patches like {\it if(a<=3)free(o1);} using the Table~\ref{instres} results. With Libfuzzer, we can see that when {\it a=4}, {\it o1} still occurs memory leak. We will start by trying alternative fix locations, however, because the function {\it func} only has one return place, we can only collect new tests to synthesize a new patch. We add {\it (a:4, error:1)} to the test suite and then use the synthesizer to generate a new patch. It's self-evident that the improved test suite enabled us to obtain the correct patch. We will utilize temporary variables to save the heap object and variables in the conditional when we apply the patch. This step is necessary to prevent these variables from changing between the allocation location and patch insertion location.

Although it is possible to fix the  {\it o1} memory leak by inserting a patch into function  {\it new\_node2}, the use-after-free problem will occur if the memory is freed too early due to the use of  {\it x->v} at line 25 of the function  {\it func}.



%---------------------------------------------
%[+] { Insert: if (true) free(*(func:x.p2)) at 3 (line 12, column 3) }
% memory dynamically allocated to `y` by call to `malloc()` at line 20, column 11 is not reachable after line 20, column 3.

%------------------------------------------------------
\subsection{Motivating Example 2}
We briefly discussed how HAMER uses fuzzing (LibFuzzer) to detect and fix errors that are not noticed by the static analyzer (Infer) in Motivating Example 1. Similarly, HAMER can avoid attempting to resolve false alarms. In Motivating Example 2, line 10 frees {\it o1} in some other way, but Infer misses it, so it assumes {\it o1} occurs memory leak. SAVER~\cite{SAVER} also ignores the fact that this is a false alarm and generates the incorrect patch, resulting in {\it double-free}. HAMER utilizes LibFuzzer to dynamically detect code, and LibFuzzer does not report issues for Motivating Example 2, therefore HAMER saves time trying to generate a fix for the wrong alarm. \textcolor{blue}{However, depending on the complexity of the function argument and the fuzzer's mutation strategy, the fuzzer may fail to visit the error path.}
%---------------------------------------------------------------------------------------
%	Approach
%----------------------------------------------------------------------------------------
\section{Approach}
\label{approach}
In this section, we describe our approach in detail, explaining what technical issues arise and how we address them. There are three major issues to consider:
\begin{itemize}
\item \textcolor{blue}{It is difficult for LibFuzzer to directly collect the high-quality test suite. How can HAMER synthesize the correct conditional?}
\item How does HAMER choose the correct fix location(s) when a function has multiple return places?
\item How does HAMER deal with several memory errors in a single function?
\end{itemize}

HAMER will solve these issues by using LibFuzzer to constantly check the patched code. In subsection~\ref{patchgeneration}, we will go over our repair algorithm in detail. Until then, we will describe how HAMER gathers the data required to fix the errors.

\subsection{Patch Template}
\textcolor{red}{
The purpose of this research is to fix temporal memory errors such as memory leak, not spatial memory errors such as buffer overflow. The most common solution for temporal memory errors is to free the memory at the correct location. As a result, the following patch template can fix the most of temporal memory errors.
}

\begin{minipage}{\textwidth}
    \vspace{0.2cm}
    \textsl{\hspace{0.3cm}$if ( cond ) free ( ob );$\\}
\end{minipage}
\textcolor{red}{
We can free the specified heap object under the specific condition by inserting a conditional deallocator. Hence, in order to generate the correct patch, we should know the following three details:}
\begin{itemize}
  \item[(1)] conditional $cond$
  \item[(2)] error heap object $ob$
  \item[(3)] fix location
\end{itemize}
\textcolor{red}{
We will present in detail how we generated the correct patch in the following subsection.
}

\subsection{Error Detection}
HAMER uses a static analyzer to find functions that may have memory errors and then uses fuzzer to detect the real errors in those functions. The purpose of applying the static analyzer is to improve HAMER's scalability, as the fuzzer always takes a long time to detect errors. Using the static analyzer to pick out candidate functions prevents fuzzer from wasting time in locations where it is not necessary. But obviously, HAMER will not be able to fix errors in functions that are not provided by the static analyzer. So for shortcode, we can just simply use fuzzer to detect errors. \textcolor{red}{After error detection, we can obtain a set $E$ that contains the details of each error reported by fuzzer, similar to the report shown in Motivating Example 1.}


\subsection{Dependency Collection}

\textcolor{red}{
We collect the error paths and error heap objects for each element in the set $E$ separately after obtaining the error report $E$. We can organize the information of each error from the error report to produce the set $EP$ using the error paths and coordinates provided by LibFuzzer. 
}

\begin{equation}
EP=\{get\_path(e)|\, e \epsilon E\}
\end{equation}
\textcolor{red}{
In Motivating Example 1 (Figure~\ref{me1}), LibFuzzer gives the error report of $o1$, and we can obtain the error path of $o1$:
}

\begin{minipage}{\textwidth}
\vspace{0.2cm}
\textsl{\hspace{0.3cm}\{funcname: func, coord: src.c:23:7, next:\\\hspace{0.6cm}\{funcname: new\_node2, coord: src.c:12:18, next:\\\hspace{0.9cm}\{funcname: malloc\}\}\}}
\vspace{0.2cm}
\end{minipage}
\textcolor{red}{
It is worthy to note that the $coord$ of each function is the error location inside the function, not the function's coordinate. All error paths, obviously, will end with an allocation function, and the coordinates of the allocation function will be kept in the previous node's $coord$, which we will use to localize the error heap object.
}

\textcolor{red}{
After organizing the error report, we collect the dependent variables in each function on the error path, which are utilized to synthesize the conditional. Fuzzer tries to trigger the function's error by inputting different data, so all the variables in the function that are dependent on the argument could be utilized to synthesize the patch's conditional. These dependent variables are collected using {\it def-use} chain, and their names, types, and coordinates are saved. During this static analysis, we also gather the return location of each function, as well as the name and type of the error heap object.
}

\textcolor{red}{
As we present in the Background, fixing the temporal memory error requires inserting the deallocation at the correct location. A memory leak will occur if allocated memory space is not freed at the end of the program, hence it is critical to free allocated memory before it is unreachable. Most of the existing memory error repair techniques~\cite{SAVER, Memfix} are based on static analysis that collects heap-related behavior, so they can insert the patch at the right location. However, the tradeoff is that it requires a high overhead, and static analysis is tough to deal with some problems such as indirect call, which may make repair tools fail to generate a patch or generate a wrong patch. HAMER aims to collect the essential information for fixing errors via lightweight static analysis. There are three major reasons why allocated memory cannot be accessed: (1) it is freed, (2) no pointer points to it, and (3) the current function exits. Memory leaks will not occur if it is properly freed. For the second reason, we will use a temporary variable to save the pointer to the error memory when it is allocated, as we will explain in detail in subsection~\ref{patchgeneration}. Hence,  we simply need to think about the third reason. A function may exit in two ways: by {\it return} or by exiting automatically at the end of the function. As a result, we just need to collect all of each function's {\it return} locations, as well as the location of the function tail, and use them as the candidate fixing location.
}

\textcolor{red}{
We extract the name and type of error heap objects at the location detected by the fuzzer. Its type is mainly determined by three factors: (1) declaration type, (2) casting type, and (3) type in the $sizeof$. For instance, the following code demonstrates how developers use $malloc$ for memory allocation:
}

\begin{minipage}{\textwidth}
\vspace{0.2cm}
\textsl{\hspace{0.3cm}int* p = (int*) malloc (sizeof (int))ï¼›}
\vspace{0.2cm}
\end{minipage}
\textcolor{red}{
We only need one of these to determine the type of the heap object, but there are indeed cases where all three are not written, such as when type is defined in a structure and then cast and sizeof are not used:
}

\begin{minipage}{\textwidth}
\vspace{0.2cm}
\textsl{\hspace{0.3cm}x->v = malloc (4)ï¼›}
\vspace{0.2cm}
\end{minipage}
\textcolor{red}{
In such cases, HAMER is unable to obtain their type, however, this is not a weakness of our approach. HAMER employs lightweight static analysis that can handle most cases. If we want to achieve higher performance, we can employ a more precise type analysis, but the tradeoff is higher overhead.
}

\textcolor{red}{
Finally, we formalized the dependency information $Dep$ as follows:
}
\begin{equation}
Dep=\{(get\_dep(path),\,get\_ret(path),\,get\_ob(path))|\, path \epsilon EP\}
\end{equation}

\subsection{Source Instrumentation}
\textcolor{red}{
We apply source instrumentation on the dependent variables after obtaining them in order to collect their dynamic values and build a test suite. A common test suite consists of several $input-output$ pairs; however, because the goal of our technique is to fix memory leaks, each $input$ corresponds to an $output$ that indicates whether or not the $input$ will trigger the error; if it does, the output is 1, otherwise, it is 0. For example, our instrumented code for the variable $a$ of the $func$ function in Figure~\ref{me1a} is as below:
}

\begin{minipage}{\textwidth}
\vspace{0.2cm}
\textsl{\hspace{0.3cm}fprintf(stderr,"instrument: (line: 17) a : \%d\textbackslash n",a);}
\vspace{0.2cm}
\end{minipage}
\textcolor{red}{
We record the locations of the variables to identify their values because the same variables will have different values at different locations. Because the results of LibFuzzer are sent to $stderr$, we also send the results of the instrumentation to $stderr$ and combine them with the results of LibFuzzer.
}

\textcolor{red}{
Our approach's overall concept of source instrumentation and dynamic values collection is shown in Algorithm~\ref{algo1}. We create a new set $SynInf$ to contain the information about fixing each error. We first define a set $dep\_var$ to store all the dependent variables in $Dep$ and for different errors, we save the dependent variables $Var$, return location $Ret$, and error heap object information $ob$ to $SynInf$. To get enough data, we use LibFuzzer to run the instrumented code 10 times and collect data for different errors. If the current execution results trigger an error, we set the $output$ of the triggered error's dependent variable to 1, otherwise, we set it to 0.
}

 \begin{algorithm}[t]
 \caption{Source Instrumentation Result Collection}
 \label{algo1}
 \begin{algorithmic}[1]
 \renewcommand{\algorithmicrequire}{\textbf{Input:}}
 \renewcommand{\algorithmicensure}{\textbf{Output:}}
 \REQUIRE src, Dep
 \ENSURE  SynInf
  \STATE $dep\_var \gets \emptyset$
  \STATE $SynInf \gets \emptyset$
  \STATE $err\_id \gets 0$
  \FOR {$(Var, Ret, ob) \in Dep$}
   \STATE $dep\_var \gets dep\_var \cup Var$
   \STATE $SynInf[err\_id].add((Var,Ret,ob))$
   \STATE $err\_id \gets err\_id + 1$
  \ENDFOR
  \STATE $inst\_code \gets \textbf{Instrument}(src, dep\_var)$
  \STATE $i \gets 0$
  \WHILE {$i < 10$}
   \STATE $res \gets \textbf{Fuzz}(inst\_code)$
    \FOR {$err\_id = 0$ to $|Dep|-1$}
     \FOR {$var \in dep\_var$}
     \IF {$memory$ $leak$ $happen$}
      \STATE $SynInf[err\_id][var].add((res[var],1))$
     \ELSE
      \STATE $SynInf[err\_id][var].add((res[var],0))$
     \ENDIF
     \ENDFOR
    \ENDFOR
   \STATE $i\gets i + 1$
  \ENDWHILE
 \end{algorithmic} 
 \end{algorithm}

\subsection{Patch Generation}
\label{patchgeneration}

\textcolor{red}{
In this section, we will present our repair algorithm and demonstrate how our repair algorithm solves the major issues we mentioned before.
}

\subsubsection{Component-based Program Synthesis}
\textcolor{red}{
Since we only need to synthesize the conditional of deallocation, we use a simplified version of component-based program synthesis (simp-CBPS). In simp-CBPS, a component is a variable, a constant, or an operator. simp-CBPS uses these user-given components to generate code that satisfies the test suite. }

\textcolor{red}{
For example, we use the following components to synthesize code that satisfies the test suite in Table~\ref{test}.
}

\begin{minipage}{\textwidth}
    \vspace{0.2cm}
    \textsl{\hspace{0.3cm}variable: x\\\hspace{0.3cm}constant: c\\\hspace{0.3cm}operator: $*_1<*_2$\\}
\end{minipage}
\textcolor{red}{
Since $<$ is a binary operator, we can construct the expression $x<c$ and $c<x$ using the variable $x$ and the constant $c$. Then we assign the value from Table~\ref{test} to get the logical formula below:
}

\begin{minipage}{\textwidth}
    \vspace{0.2cm}
    \textsl{\hspace{0.3cm}$x<c: (4<c)\wedge(5<c)\wedge\neg(6<c)\wedge\neg(7<c)$\\\hspace{0.3cm}$c<x: (c<4)\wedge(c<5)\wedge\neg(c<6)\wedge\neg(c<7)$\\}
\end{minipage}
\textcolor{red}{
We have turned the program synthesis problem into {\it Satisfiability Modulo Theories} (SMT) by doing the above action. We solve the logical formula via the SMT solver. If a logical formula is unsatisfiable, it means that the present synthesized expression does not pass the test suite, indicating that it is not the expected expression. For example, the second logical formula is unsatisfiable, hence $c<x$ is not the correct expression. The first logical formula is satisfiable and the result is $c=6$, so we can get the expected expression $x<6$.
}

\begin{table}[h]
  \caption{test suite}
  \label{test}
  \centering
  \begin{tabular}{|c|c|}
    \hline
     x & output \\
    \hline
     4 & True \\
     5 & True \\
     6 & False \\
     7 & False \\
    \hline
  \end{tabular}
\end{table}

\textcolor{red}{
The quality of the test suite is the most critical part of using CBPS to synthesize expressions. CBPS will synthesize incorrect expressions if the test suite provided by the user is of poor quality. If Table~\ref{test} does not have $(x=6, output=False)$, for example, we might obtain $x<7$.
}

\subsubsection{Repair Algorithm}
\textcolor{red}{
The input of our repair algorithm (Algorithm~\ref{repalgo}) is the source code and the collected information $SynInf$, and the output is the fixed code generated by HAMER. We use a $queue$ to keep the number of each error and repair them one by one. When repairing, we first pop an error number from the $queue$ and then get the corresponding information from $SynInf$. After that, we synthesize the conditional of the patch using $simp-CBPS$. Because all the functions on the error path have the potential to become the fix location, $simp-CBPS$ synthesizes all satisfiable patches, and the fix location and heap object information corresponding to the patch are gathered and saved to $cur\_patches$.
}

\textcolor{red}{
After that, we synthesize the patch and use the function $Fix$ (Algorithm~\ref{funcfix}) to insert it in the right location. If the currently generated patch fails to fix the error, we gather the test that triggers the error and append it to the test suite. For example, when HAMER fixes the memory leak of $o1$ in Figure~\ref{me1a} of Motivating Example1, it's difficult to collect enough tests directly, thus the next two incorrect patches could be synthesized:
}

\begin{minipage}{\textwidth}
    \vspace{0.2cm}
    \textsl{\hspace{0.3cm}(1) if (a<=3)free(o1);\\\hspace{0.3cm}(2) if (a<=5)free(o1);}
\end{minipage}
\textcolor{red}{
If $simp-CBPS$ does not get the test $(a:4, error:1)$, it will synthesize the conditional of the first wrong patch, and if it does not get the test $(a:5, error:0)$, it will synthesize the conditional of the second wrong patch. For the first patch, we can get that memory leak will happen when $a=4$ via LibFuzzer, so we add $(a:4, error:1)$ to the test suite. For the second patch, when $a=5$, since $o1$ is not defined yet, free it is undefined behavior, so we add $(a:5, error:0)$ to the test suite. Similarly, if a test triggers a double free, we will add this test and $(error:0)$ to the test suite, indicating that this heap object has already been deallocated at this test.
}

\textcolor{red}{
We keep the patch of the current error if this error is fixed, and we clear the test suite in $SynInf$ if there still have errors to be fixed. The goal of this step is to save space and speed up the SMT solver computation. $SynInf$ takes up a lot of space because the test suite is constantly updated. The quality of the gathered test suite will also be affected if a function has several errors. We can recollect the test suite when an error is fixed to receive a higher-quality test suite and save space. If the current error is not fixed, we add the error number to the queue and try to fix it later.
}

\textcolor{red}{
To ensure that our algorithm terminates at the right time, we use two methods. The first occurs in line 9. If $simp-CBPS$ synthesizes the same patch as last time, indicating that this error is difficult to fix in the current situation. In most cases, we are unable to collect a high-quality test suite due to multiple errors in the function, so we give up trying to fix this error for the time being and return to it after fixing other, much simpler errors. The second is that we create an $unfixederror$ variable to keep track of errors that we try to fix but can not. Because there may sometimes be several errors that HAMER cannot solve, we stop HAMER if none of the remaining errors are fixed after HAMER tries to fix them.
}

 \begin{algorithm}[t]
 \caption{Repair Algorithm}
 \label{repalgo}
 \begin{algorithmic}[1]
 \renewcommand{\algorithmicrequire}{\textbf{Input:}}
 \renewcommand{\algorithmicensure}{\textbf{Output:}}
 \REQUIRE src, SynInf
 \ENSURE  fixed\_code
  \STATE $fixed\_code \gets src$
  \STATE $queue \gets \{0,1,...,|SynInf|-1\}$
  \STATE $unfixederror = 0$
  \WHILE {$|queue| \ne 0 $ and $unfixederror \ne |queue| $}
   \STATE $err\_id \gets queue.pop$
   \STATE $err\_inf \gets SynInf[err\_id]$
   \REPEAT
    \STATE $cur\_patches \gets \textbf{simp-CBPS}(err\_inf)$
    \IF {$cur\_patches$ $same$ $as$ $last$ $time$}
     \STATE $\textbf{break}$
    \ENDIF
    \STATE $cur\_code \gets \textbf{Fix}(cur\_patches,fixed\_code)$
    \IF {$not$ $fixed$}
     \STATE $err\_inf \gets \textbf{Update}(err\_inf)$
    \ENDIF
   \UNTIL {$timeout$ or $error$ $fixed$}
   \IF {$current$ $error$ $fixed$}
    \STATE $fixed\_code \gets cur\_code$
    \STATE $unfixederror \gets 0$
    \IF {$queue$ $is$ $not$ $empty$}
     \STATE $SynInf \gets \textbf{Clean}(SynInf)$
     \STATE $SynInf \gets \textbf{Update}(SynInf)$
    \ENDIF
   \ELSE
    \STATE $queue.add(err\_id)$
    \STATE $unfixederror \gets unfixederror + 1$
   \ENDIF
  \ENDWHILE  
 \end{algorithmic} 
 \end{algorithm}


\subsubsection{Function Fix}
\textcolor{red}{
It is critical to insert the patch in the correct location in order to fix temporal memory errors. Function $Fix$ to determine if the fix location is correct. We test the patch and the fix location of each function on the error path one by one. Fuzzer checks a patch when it is inserted into a fix location. If the patch introduces a new error in the existing fix location, it is clear that the fix location is incorrect, and we should try a different fix location. If no new errors are raised but the existing error remains unfixed, it is possible that the current fix location only partially fixed the error; in that case, we save the patch inserted at the current fix location and try other fix locations. The following code, for example, has two returns, and we must apply the patch to both of them to fix the error.
}

\begin{minipage}{\textwidth}
    \vspace{0.2cm}
    \textsl{\hspace{0.3cm}p=malloc(1);\\\hspace{0.3cm}if(c)\{\\\hspace{0.6cm}use(p);\\\hspace{0.6cm}return 0;\\\hspace{0.3cm}\}else\{\\\hspace{0.6cm}use(p);\\\hspace{0.6cm}return 1;\\\hspace{0.3cm}\}}
\end{minipage}
\textcolor{red}{
The memory leak was not fixed when we inserted the patch before the first $return$, so we kept the current patch and inserted the patch before the second $return$, and then the error was correctly fixed.
}


 \begin{algorithm}[t]
 \caption{Function Fix}
 \label{funcfix}
 \begin{algorithmic}[1]
 \renewcommand{\algorithmicrequire}{\textbf{Input:}}
 \renewcommand{\algorithmicensure}{\textbf{Output:}}
 \REQUIRE cur\_patches, code
 \ENSURE  fixed\_code
  \STATE $test\_code \gets code$
  \FOR {$(cur\_patch,Ret) \in cur\_patches$}
   \FOR {$retloc \in Ret$}
    \STATE $test\_code \gets \textbf{InsertPatch}((cur\_patch,retloc))$
    \STATE $\textbf{Fuzz}(test\_code)$
    \IF {$new$ $error$ $occurs$}
     \STATE $test\_code \gets code$
     \STATE $\textbf{continue}$
    \ELSIF {$same$ $error$ $occurs$}
     \STATE $\textbf{continue}$
    \ELSE 
     \STATE $\textbf{return}$ $test\_code$
    \ENDIF
   \ENDFOR
  \ENDFOR
  \STATE $\textbf{return}$ $\emptyset$
 \end{algorithmic} 
 \end{algorithm}

\subsubsection{Temporary Variable}
\textcolor{red}{
We use temporary variables to store the variables used in the patch conditional and the error heap object while inserting patches. Because the values of these significant variables may modify between the error source and the fix location, analyzing these changes requires complex static analysis. To address this issue without increasing the complexity of our algorithm, we use temporary variables to store the values of these variables, so that even if their values change, the patches generated by HAMER are still correct (e.g., Figure~\ref{me1b}).
}



%----------------------------------------------------------------------------------------
%	Evaluation
%----------------------------------------------------------------------------------------
\section{Evaluation}
\begin{itemize}
\item[\textbf{RQ1.}] Compared with state-of-the-art automated memory error repair tool \textbf{SAVER}, what is the overall effectiveness of HAMER?
\item[\textbf{RQ2.}] Can HAMER address the three major issues we mentioned before? 
\item[\textbf{RQ3.}] How efficient is HAMER in using lightweight static analysis?
\end{itemize}

\begin{table}[h]
  \caption{Evaluation result of HAMER and SAVER. ML denotes the number of memory leaks. True, F.P. and F.N. denote the number of true, false-positive, and false-negative alarms detected by Infer. Fuzz denotes the number of memory leaks detected by LibFuzzer. $\checkmark$ and $\times$ report the correct and wrong patches generated by HAMER and SAVER. S.A. and sec report the static analysis time and the overall fix time }
  \label{evaluationresult}
  \centering
  \begin{tabular}{ccc|ccc|ccccc|cccc}
                 &        &           &  \multicolumn{3}{|c|}{Infer} & \multicolumn{5}{|c|}{HAMER} &  \multicolumn{4}{|c}{SAVER} \\
   programs& LoC & ML     & True& F.P. & F.N. & Fuzz & $\checkmark$ & $\times$ & S.A. & sec & $\checkmark$ &$\times$ & S.A.& sec \\
    \hline
    test1     & 30    & 2        & 1     & 1     & 0     & 2       & 2                    & 0             &   2   & 5    & 1                     & 0           &    3  & 5 \\
    \hline
  \end{tabular}
\end{table}
\textbf{synthesize code:}\\
multiple memory leaks: 5 \\
multiple returns: 5 \\
long error path: 5 \\
difficult control flow: 5 \\
large size program: 5 \\
Infer false-positive alarms and false-negative alarms: 5 \\



%---------------------------------------------------------------------------------------
%      Limitation
%----------------------------------------------------------------------------------------
\section{Limitation}

%---------------------------------------------------------------------------------------
%      future work
%----------------------------------------------------------------------------------------
\section{Future Work}


%---------------------------------------------------------------------------------------
%      Related work
%----------------------------------------------------------------------------------------
\section{Related Work}
CPR~\cite{CPR}, Angelix~\cite{Angelix}, Extractfix~\cite{Extractfix}, Getafix~\cite{Getafix}, SAVER~\cite{SAVER}, Memfix~\cite{Memfix}



%---------------------------------------------------------------------------------------
%      Conclusion	
%----------------------------------------------------------------------------------------
\section{Conclusion}


%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------

\def\newblock{\hskip .11em plus .33em minus .07em}
\bibliographystyle{plain}
\bibliography{mybib}

%----------------------------------------------------------------------------------------

\end{document}
