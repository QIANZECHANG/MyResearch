%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Journal Article
% LaTeX Template
% Version 1.4 (15/5/16)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com) with extensive modifications by
% Vel (vel@LaTeXTemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

%\documentclass[twoside,twocolumn,a4j,dvipdfmx]{article}
\documentclass[a4j,dvipdfmx]{article}
%\usepackage{blindtext} % Package to generate dummy text throughout this template 

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage[english]{babel} % Language hyphenation and typographical rules

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text

\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
\renewcommand\thesubsection{\roman{subsection}} % roman numerals for subsections
\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
%\pagestyle{fancy} % All pages have headers and footers
%\fancyhead{} % Blank out the default header
%\fancyfoot{} % Blank out the default footer
%\fancyhead[C]{Running title $\bullet$ May 2016 $\bullet$ Vol. XXI, No. 1} % Custom header text
%\fancyfoot[RO,LE]{\thepage} % Custom footer text

\usepackage{titling} % Customizing the title section
\usepackage[dvipdfmx]{color}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric,arrows,positioning}
\usepackage{hyperref} % For hyperlinks in the PDF
\usepackage{color}
\usepackage{caption,subcaption}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{mathtools}
\usepackage{algorithm,algorithmic}

%--------------------------------------------
% code style
%---------------------------------------------
%\usepackage{lstlinebgrd}
\usepackage{xcolor}
\usepackage{listings}
\renewcommand\lstlistingname{Figure}
\renewcommand\lstlistlistingname{Figures}

% Color
\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}
\definecolor{Blue}{HTML}{2d5ae0}
\definecolor{Orange}{HTML}{e33900}
\definecolor{Green}{HTML}{009e73}
\definecolor{Purple}{HTML}{9400d3}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    frame=single,
    framexleftmargin=1em,
    %xleftmargin=0.5em,
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}

%----------------------------------------------
%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\setlength{\droptitle}{-4\baselineskip} % Move the title up

\pretitle{\begin{center}\Huge\bfseries} % Article title formatting
\posttitle{\end{center}} % Article title closing formatting
\title{Automated Memory Error Repair Based on Hybrid Program Analysis} % Article title
\author{ ZECHANG QIAN \\ (Supervisor:  Katsuhiko Gondow)}
%\textsc{John Smith}\thanks{A thank you or further information} \\[1ex] % Your name
%\normalsize University of California \\ % Your institution
%\normalsize \href{mailto:john@smith.com}{john@smith.com} % Your email address
%\and % Uncomment if 2 authors are required, duplicate these 4 lines if more
%\textsc{Jane Smith}\thanks{Corresponding author} \\[1ex] % Second author's name
%\normalsize University of Utah \\ % Second author's institution
%\normalsize \href{mailto:jane@smith.com}{jane@smith.com} % Second author's email address

\date{} % Leave empty to omit a date
\renewcommand{\maketitlehookd}{%
\begin{abstract}
Automated program repair is a technology which aims to fix program errors and vulnerabilities automatically. In the field of memory error repair, with the development of bug detection tools, we can easily detect memory errors in programs. However, fixing those errors is time-consuming and error-prone. Because the program’s heap-related behavior plays a critical role in memory error repair, the existing techniques are mainly based on static analysis, where the static analyzer is used to detect program memory errors and then repair tools collect the essential information via static analysis. But since static analyzer may give wrong alarms which will affect the performance of the repair tools, and static analysis often requires high overhead. 

We present \textbf{HAMER}, a hybrid automated memory error repair tool that aims to address those 
shortcomings by using hybrid analysis. HAMER first uses fuzzer to check the alarms given by the static 
analyzer and extracts the real errors from those alarms. Then it tries to fix those errors by using 
hybrid analysis. \textcolor{blue}{HAMER is the first automated memory error repair technique based on fuzzing results. HAMER does not waste time resolving alarms that are incorrect because the errors reported by fuzzer are real errors, and HAMER also utilizes fuzzer to test the generated patches to ensure they are correct. For the necessary information for synthesizing patches, HAMER uses lightweight static analysis techniques to collect it.} \textcolor{red}{evaluation and conclusion}
\end{abstract}
}

%----------------------------------------------------------------------------------------

\begin{document}

% Print the title
\maketitle

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\section{Introduction}
Memory errors, such as memory leaks, can have catastrophic effects,  thus detecting and fixing them has always been a critical task for developers. Memory error detection performance is improving with the development of memory error detection technologies, however resolving these problems takes a lot of time and work for developers, and erroneous patches might lead to more significant effects.

Existing memory error repair techniques~\cite{SAVER,Memfix} are mainly based on static analysis. This is because resolving issues like memory leaks necessitates an understanding of heap-related behavior, such as error source and sink. \textcolor{blue}{Collecting heap-related behavior information has a high time and space overhead. Because wrong patches or fixing locations might lead to more significant errors, and different heap objects can interact with each other, all of this must be fully considered when generating patches. The state-of-the-art automated memory error repair technology SAVER~\cite{SAVER} saves these heap-related behaviors by constructing object flow graph, which has high time and space complexity. However, because static analysis techniques are not good at dealing with problems such as indirect calls and alias, the repair tools which based on static analysis might generate the wrong patches.} While dynamic analysis can help with these issues, it does not provide enough information to generate patches.

In this paper, we present \textbf{HAMER}, a hybrid analysis-based memory error repair \mbox{technique}. We use a static analyzer to detect the program first, then use a fuzzer to detect the alarms and extract the real errors. \textcolor{blue}{Fuzzer triggers runtime errors, thus it will not give false-positive alarms, allowing HAMER to avoid fixing wrong alarms.} After that, we collect program variables that can be utilized to synthesize patches by variable dependency analysis. \textcolor{blue}{During this procedure, we also collect the return locations of each function as the candidate fix locations. With this lightweight static analysis, HAMER is able to obtain enough information to fix the buggy program.} We then gather the test cases generated by the fuzzer which trigger or do not trigger the errors and use the component-based program synthesis~\cite{oracle} to try to generate patches from these variables and test cases. Finally, we utilize the fuzzer to detect the current fixed program, and if the repair is erroneous, we collect the test case that triggers the errors and repeat our repair method until the error is resolved or timeout. This strategy ensures that the patches generated by HAMER can repair current errors while without introducing new ones. \textcolor{red}{evaluation and conclusion}

\textbf{Contributions.} This paper makes the following contributions:
\begin{itemize}
  \item We present a new technique for repairing memory errors based on hybrid analysis. \textcolor{blue}{Our approach collect the relevant information using a lightweight static analysis, then repeatedly synthesize the patch and test it with fuzzer.}
  \item We present HAMER~\footnote{https://github.com/QIANZECHANG/MyResearch(仮)}, a memory error repair tool that implements the proposed approach.
\end{itemize}

%------------------------------------------------
%Backgroud
%----------------------------------------------------------------------------------------
\section{Background}
\textcolor{red}{
HAMER detects bugs using existing bug detection tools. In this section, we will introduce the static analyzer (Infer~\footnote{https://fbinfer.com/}) and fuzzer (LibFuzzer~\footnote{https://llvm.org/docs/LibFuzzer.html}) that HAMER uses, as well as the patch generation technique (component-based program synthesis~\cite{oracle} （CBPS）). We will also present the patch template we used to fix the error.
}
\subsection{Infer}
\textcolor{red}{
Infer is a static program analyzer for Java, C, and Objective-C, written in OCaml, developed by Facebook. At present Infer is tracking problems caused by null pointer dereferences and resource and memory leaks, which cause some of the more important problems. Infer is a high-performance static analyzer with high scalability and efficiency, and it is widely used by programmers and researchers. However, like other static analyzers, Infer is hard to handle some issues, such as indirect call and alias, which causes Infer to provide false-negative and false-positive alarms. As a result of this shortcoming, automated repair tools may waste time on the wrong alarms (false-positive) and have no way to fix the errors that are not discovered (false-negative).
}

\subsection{LibFuzzer}
\textcolor{red}{
LibFuzzer is an in-process, coverage-guided, evolutionary fuzzing engine. LibFuzzer is linked with the library under test, and feeds fuzzed inputs to the library via a specific fuzzing entry point (target function); the fuzzer then tracks which areas of the code are reached, and generates mutations on the corpus of input data in order to maximize the code coverage. The code coverage information for libFuzzer is provided by LLVM’s SanitizerCoverage~\footnote{https://clang.llvm.org/docs/SanitizerCoverage.html} instrumentation.
}	

\textcolor{red}{
LibFuzzer uses the information provided by the AddressSanitizer~\footnote{https://clang.llvm.org/docs/AddressSanitizer.html} to determine if an error has happened within the detected code coverage when detecting memory errors. When the program allocates memory, the allocated space is marked, and the behavior is verified for legality each time the space is accessed. These memory spaces are checked at the end of the program to see if they have been freed.
}

\textcolor{red}{
Because LibFuzzer can only fuzz test one function argument at a time, we must test each argument independently for functions with multiple arguments. LibFuzzer may fail to mutate the inputs that go into all paths for some functions with complex input. Furthermore, LibFuzzer will stop and report errors anytime it triggers the error, thus if a function has several errors, LibFuzzer cannot ensure that all of them will be detected at the same time. The code below, for example, has two memory leaks. 
}

\begin{minipage}{\textwidth}
    \vspace{0.2cm}
    \textsl{\hspace{0.3cm}p1 = malloc(1);\\\hspace{0.3cm}if (a == 5) p2 = malloc(1);\\}
\end{minipage}
\textcolor{red}{
The ideal situation would be for LibFuzzer to input {\it a=5} and trigger both errors. But in most cases,  LibFuzzer inputs other values only triggers the memory leak of {\it p1} and then exits. To improve, we run LibFuzzer several times to detect as many errors as possible.
}
\subsection{Component-based Program Synthesis}
\textcolor{red}{
Since we only need to synthesize the conditional of deallocation, we use a simplified version of component-based program synthesis (simp-CBPS). In simp-CBPS, a component is a variable, a constant, or an operator. simp-CBPS uses these user-given components to generate code that satisfies the test suite. }

\textcolor{red}{
For example, we use the following components to synthesize code that satisfies the test suite in table1.
}

\begin{minipage}{\textwidth}
    \vspace{0.2cm}
    \textsl{\hspace{0.3cm}variable: x\\\hspace{0.3cm}constant: c\\\hspace{0.3cm}operator: $*_1<*_2$\\}
\end{minipage}
\textcolor{red}{
Since $<$ is a binary operator, we can construct the expression $x<c$ and $c<x$ using the variable $x$ and the constant $c$. Then we assign the value from Table~\ref{test} to get the logical formula below:
}

\begin{minipage}{\textwidth}
    \vspace{0.2cm}
    \textsl{\hspace{0.3cm}$x<c: (4<c)\wedge(5<c)\wedge\neg(6<c)\wedge\neg(7<c)$\\\hspace{0.3cm}$c<x: (c<4)\wedge(c<5)\wedge\neg(c<6)\wedge\neg(c<7)$\\}
\end{minipage}
\textcolor{red}{
We have turned the program synthesis problem into {\it Satisfiability Modulo Theories} (SMT) by doing the above action. We solve the logical formula via SMT solver. If a logical formula is unsatisfiable, it means that the present synthesized expression does not pass the test suite, indicating that it is not the expected expression. For example, the second logical formula is unsatisfiable, hence $c<x$ is not the correct expression. The first logical formula is satisfiable and the result is $c=6$, so we can get the expected expression $x<6$.
}

\begin{table}[h]
  \caption{test suite}
  \label{test}
  \centering
  \begin{tabular}{|c|c|}
    \hline
     x & output \\
    \hline
     4 & True \\
     5 & True \\
     6 & False \\
     7 & False \\
    \hline
  \end{tabular}
\end{table}

\textcolor{red}{
The quality of the test suite is the most critical part of using CBPS to synthesize expressions. CBPS will synthesize incorrect expressions if the test suite provided by the user is of poor quality. If Table~\ref{test} does not have $(x=6, output=False)$, for example, we might obtain $x<7$.
}

\subsection{Patch Template}
\textcolor{red}{
The purpose of this research is to fix temporal memory errors such as memory leak, not spatial memory errors such as buffer overflow. The most common solution for temporal memory errors is to free the memory at the correct location. As a result, the following patch template can fix the most of temporal memory errors.
}

\begin{minipage}{\textwidth}
    \vspace{0.2cm}
    \textsl{\hspace{0.3cm}$if ( cond ) free ( ob );$\\}
\end{minipage}
\textcolor{red}{
We can free the specified heap object under the specific condition by inserting a conditional deallocator. Hence, in order to generate the correct patch, we should know the following three details:}
\begin{itemize}
  \item[(1)] conditional $cond$
  \item[(2)] error heap object $ob$
  \item[(3)] fix location
\end{itemize}
\textcolor{red}{
We will present in detail how we generated the correct patch in section~\ref{approach}.
 }
%------------------------------------------------
%	Overview
%----------------------------------------------------------------------------------------
\section{Overview}

We illustrate key features of HAMER and how it works. Figure~\ref{pipeline} depicts a high-level overview of the HAMER pipeline.

First, we check the program with the static analyzer \mbox{Infer}, and then we manually collect the functions that contain Infer alarms. Following that, these functions are fuzzed by LibFuzzer to detect true errors.  For those functions on the error path, we collect the variables that are dependent on the function arguments and stub them. \textcolor{blue}{Dependent variables will be used to synthesize the conditional of the patch. After that, we instrument all of the dependent variables and run the program via LibFuzzer to collect the tests that do or do not trigger the error.} Finally, we use \textcolor{blue}{a simplified component-based program synthesis (simp-CBPS)} to generate patches. Because the quality of the test suite affects the quality of the patch, we use LibFuzzer to check the current fixed code again, and if it has not been fixed or if a new error occurs, we collect the tests that cause the error or insert the patch in a different location. This strategy ensures that the patches generated by HAMER are correct and do not introduce new errors. In the following paragraphs of this section, we will use two motivating examples to demonstrate the workflow and characteristics of HAMER.

%----------------pipeline-----------------------------------
\tikzstyle{tool} = [diamond, draw, fill=green!20, text centered, text width=4.5em, aspect=2]
\tikzstyle{block} = [rectangle, draw, fill=blue!20, text width=7em, rounded corners, minimum height=3em]
\tikzstyle{block2} = [rectangle, draw, fill=blue!20, text centered, text width=7em, rounded corners, minimum height=3em]
\tikzstyle{line} = [thick,->,>=stealth]
\tikzstyle{outdata} = [rectangle, draw, fill=brown!20, text width=5em, minimum height=3em]
\tikzstyle{code} = [draw, ellipse,fill=red!20, text width=2em, minimum height=3em]
\tikzstyle{bigcode} = [draw, ellipse,fill=red!20, text width=5.5em, minimum height=3em]
\begin{figure*}[ht]
\hspace{-0.5cm}
\begin{tikzpicture}[node distance = 3.5cm, on grid]
  %node
  \node[tool] (infer){Infer};
  \node[code, below of=infer,yshift=1.5cm] (src){src.c};
  \node[outdata, right of=infer] (efunc){error\\functions};
  \node[tool, right of=src] (fuzzer1){LibFuzzer};
  \node[outdata, below of=fuzzer1, yshift=1.5cm] (error){true errors};
  \node[block, below of=error,yshift=2cm] (dep){Dependency\\Collection};
  \node[outdata, right of=dep] (depvar){dependent\\variables};
  \node[block, right of=error,yshift=1cm] (inst){Source\\Instrumentation};
  \node[bigcode, right of=fuzzer1,yshift=1cm] (instcode){Instrumented\\code};
  \node[tool, right of=instcode] (fuzzer2){LibFuzzer};
  \node[outdata, right of=inst] (test){test suite};
  \node[block2, right of=depvar] (syn){simp-CBPS};
  \node[bigcode, right of=syn] (fix){current\\fixed code};
  \node[code, above of=fuzzer2,yshift=-1.5cm] (output){out.c};
  \node[right of=output,yshift=-1cm,xshift=-2.5cm] (no){no error}; 
  \node[below of=no,yshift=1.5cm,xshift=-0.3cm] (yes){error}; 
 %edge
  \draw [line] (src) -- (infer);
  \draw [line] (src) -- (fuzzer1);
  \draw [line] (infer) -- (efunc);
  \draw [line] (efunc) -- (fuzzer1);
  \draw [line] (fuzzer1) -- (error);
  \draw [line] (error) -- (dep);
  \draw [line] (src) |- (dep);
  \draw [line] (dep) -- (depvar);
  \draw [line] (depvar) -- (inst);
  \draw [line] (inst) -- (instcode);
  \draw [line] (instcode) -- (fuzzer2);
  \draw [line] (fuzzer2) -- (test);
  \draw [line] (test) -- (syn);
  \draw [line] (depvar) -- (syn);
  \draw [line] (syn) -- (fix);
  \draw [line] (fix) |- (fuzzer2);
  \draw [line] (fuzzer2) -- (output);
  \draw [line] (src) |- (inst);
\end{tikzpicture}
  \caption{HAMER pipeline}
  \label{pipeline}
\end{figure*}
%----------------code---------------------------
\lstset{
  style=CStyle,
  moredelim=[is][\color{Blue}\bfseries]{<\#blue\#}{\#>},
  moredelim=[is][\color{Orange}\bfseries]{<\#orange\#}{\#>},
  moredelim=[is][\color{Green}\bfseries]{<\#green\#}{\#>},
  moredelim=[is][\color{Purple}\bfseries]{<\#purple\#}{\#>},
}

\begin{figure*}
  \begin{subfigure}{0.47\textwidth}
    \lstinputlisting{src.c}
    \caption{o0, o1, o2 occur memory leak}
    \label{me1a}
  \end{subfigure}\hfill
  \begin{subfigure}{0.45\textwidth}
    \lstinputlisting[firstline=17,firstnumber=17]{result_src.c}
    \caption{HAMER-generated patch}
    \label{me1b}
  \end{subfigure}
  \caption{Motivating Example 1: Infer false-negative alarm} 
  \label{me1}
\end{figure*}

\begin{figure*}
  \begin{subfigure}{0.47\textwidth}
    \lstinputlisting{saver.c}
    \caption{No memory leak}
  \end{subfigure}\hfill
  \begin{subfigure}{0.45\textwidth}
    \lstinputlisting{saver_result.c}
    \caption{SAVER-generated patch}
  \end{subfigure}
  \caption{Motivating Example 2: Infer false-positive alarm}
  \label{me2}
\end{figure*}

\subsection{Motivating Example 1}
This buggy code has three memory leaks, denoted by {\it o0}, {\it o1}, and {\it o2}, as shown in Figure~\ref{me1a}. First, we use Infer to detect this code, obtaining the following result:

\begin{minipage}{\textwidth}
\vspace{0.2cm}
\textsl{\hspace{0.3cm}Object allocated at line 20 is unreachable at line 20.\\}
\end{minipage}

Because static analyzers like Infer have a difficult time resolving issues like indirect calls, they can only detect the memory leak of {\it o2}. After we received the Infer results, the error function was detected again by LibFuzzer, and all errors were successfully detected. For example, for {\it o1}, we can get the fuzzing result shown below:


\begin{minipage}{\textwidth}
    \vspace{0.2cm}
    \textsl{\hspace{0.3cm}in malloc ../a.out\\\hspace{0.3cm}in new\_node2 ../src.c:12:18\\\hspace{0.3cm}in func ../src.c:23:7\\}
\end{minipage}

We can get all of the functions on the error path using LibFuzzer. Obviously, the correct fix location could be in any of the functions, so we collect the variables that are dependent on the function argument, and we also collect both the heap object information and the return location of each function during this static analysis. 

\begin{table}[h]
  \caption{Instrumentation result of o1}
  \label{instres}
  \centering
  \begin{tabular}{|c|c|c|c|}
    \hline
    func  & \multicolumn{2}{|c|}{new\_node2} & \multirow{2}{*}{error} \\
    \cline{1-3}
    a & a & n->v &\\
    \hline
     0 & 0  & 0 & 1\\
     5 & 5  & 25 & 0\\
     6 & 6  & 36 & 0\\
     8 & 8  & 64 & 0\\
    \hline
  \end{tabular}
\end{table}

Following that, we instrument all of the dependent variables and run the source instrumented code through Libfuzzer to collect dynamic values for each dependent variable. Table~\ref{instres} displays the results of o1's collection. The {\it error} column indicates whether or not \textcolor{blue}{memory leak} occurred at the current value, with 1 indicating that it did and 0 indicating that it did not. Table~\ref{instres} shows that {\it o1} leaks when the variable {\it a} in the function {\it func} is less than or equal to 4. We can synthesize the ideal patch using simp-CBPS, which is:

\begin{minipage}{\textwidth}
\vspace{0.2cm}
\hspace{0.3cm}
\raggedright
\verb|if(a<=4)free(x);|
\label{patch1}
\vspace{0.2cm}
\end{minipage}

Finally, we use LibFuzzer to detect the patched code, and if it fixes the current bug, we keep the patch and fix other bugs until all bugs are fixed or time out. If the current patch does not fix the bug or causes a new bug, we try to insert the patch into another location or collect new tests to synthesize a new patch. For example, we can also synthesize patches like {\it if(a<=3)free(x);} using the Table~\ref{instres} results. With Libfuzzer, we can see that when {\it a=4}, {\it o1} still occurs memory leak. We will start by trying alternative fix locations, however, because the function {\it func} only has one return place, we can only collect new tests to synthesize a new patch. We add {\it (a:4, error:1)} to the test suite and then use the synthesizer to generate a new patch. It's self-evident that the improved test suite enabled us to obtain the correct patch. We will utilize temporary variables to save the heap object and variables in the conditional when we apply the patch. This step is necessary to prevent these variables from changing between the allocation location and patch insertion location.

Although it is possible to fix the  {\it o1} memory leak by inserting a patch into function  {\it new\_node2}, the use-after-free problem will occur if the memory is freed too early due to the use of  {\it x->v} at line 25 of the function  {\it func}.



%---------------------------------------------
%[+] { Insert: if (true) free(*(func:x.p2)) at 3 (line 12, column 3) }
% memory dynamically allocated to `y` by call to `malloc()` at line 20, column 11 is not reachable after line 20, column 3.

%------------------------------------------------------
\subsection{Motivating Example 2}
We briefly discussed how HAMER uses fuzzing (LibFuzzer) to detect and fix errors that are not noticed by the static analyzer (Infer) in Motivating Example 1. Similarly, HAMER can avoid attempting to resolve false alarms. In Motivating Example 2, line 10 frees {\it o1} in some other way, but Infer misses it, so it assumes {\it o1} occurs memory leak. SAVER~\cite{SAVER} also ignores the fact that this is a false alarm and generates the incorrect patch, resulting in {\it double-free}. HAMER utilizes LibFuzzer to dynamically detect code, and LibFuzzer does not report issues for Motivating Example 2, therefore HAMER saves time trying to generate a fix for the wrong alarm. \textcolor{blue}{However, depending on the complexity of the function argument and the fuzzer's mutation strategy, the fuzzer may fail to visit the error path.}
%---------------------------------------------------------------------------------------
%	Approach
%----------------------------------------------------------------------------------------
\section{Approach}
\label{approach}
In this section, we describe our approach in detail, explaining what technical issues arise and how we address them. There are three major issues to consider:
\begin{itemize}
\item It is difficult for LibFuzzer to directly collect enough test suites to synthesize the correct patches. \textcolor{blue}{How can HAMER synthesize the correct conditional?}
\item How does HAMER choose the correct fix location(s) when a function has multiple return places?
\item How does HAMER deal with several memory errors in a single function?
\end{itemize}

HAMER will solve these issues by using LibFuzzer to constantly check the patched code. In subsection~\ref{repair}, we will go over our repair algorithm in detail. Until then, we will describe how HAMER gathers the data required to resolve the errors.

\subsection{Error Detection}
HAMER uses a static analyzer to find functions that may have memory errors and then uses fuzzer to detect the real errors in those functions. The purpose of applying the static analyzer is to improve HAMER's scalability, as the fuzzer always takes a long time to detect errors. Using the static analyzer to pick out candidate functions prevents fuzzer from wasting time in locations where it is not necessary. But obviously, HAMER will not be able to fix errors in functions that are not provided by the static analyzer. So for shortcode, we can just simply use fuzzer to detect errors. \textcolor{red}{After error detection, we can obtain a set $E$ that contains the details of each error reported by fuzzer, similar to the report shown in Motivating Example 1.}


\subsection{Dependency Collection}
\begin{equation}
EP=\{(get\_path(e),\,get\_ob(e))|\, e \epsilon E\}
\end{equation}

\begin{equation}
Dep=\{(get\_dep(path),\,get\_ret(path),\,ob)|\, (path,ob) \epsilon EP\}
\end{equation}

\subsection{Source Instrumentation}


 \begin{algorithm}
 \caption{Source Instrumentation Result Collection}
 \label{srcinst}
 \begin{algorithmic}[1]
 \renewcommand{\algorithmicrequire}{\textbf{Input:}}
 \renewcommand{\algorithmicensure}{\textbf{Output:}}
 \REQUIRE src, Dep
 \ENSURE  SynInf
  \STATE $dep\_var \gets \emptyset$
  \STATE $SynInf \gets \emptyset$
  \STATE $err\_id \gets 0$
  \FOR {$(Var, Ret, ob) \in Dep$}
   \STATE $dep\_var \gets dep\_var \cup Var$
   \STATE $SynInf[err\_id].add((Ret,ob))$
   \STATE $err\_id \gets err\_id + 1$
  \ENDFOR
  \STATE $inst\_code \gets \textbf{Instrument}(src, dep\_var)$
  \STATE $i \gets 0$
  \WHILE {$i < 10$}
   \STATE $res \gets \textbf{Fuzz}(inst\_code)$
    \FOR {$err\_id = 0$ to $|Dep|-1$}
     \FOR {$var \in dep\_var$}
     \IF {$memory$ $leak$ $happen$}
      \STATE $SynInf[err\_id][var].add((res[var],1))$
     \ELSE
      \STATE $SynInf[err\_id][var].add((res[var],0))$
     \ENDIF
     \ENDFOR
    \ENDFOR
   \STATE $i\gets i + 1$
  \ENDWHILE
 \end{algorithmic} 
 \end{algorithm}

\subsection{Patch Generation}
\label{repair}

 \begin{algorithm}
 \caption{Repair Algorithm}
 \label{repalgo}
 \begin{algorithmic}[1]
 \renewcommand{\algorithmicrequire}{\textbf{Input:}}
 \renewcommand{\algorithmicensure}{\textbf{Output:}}
 \REQUIRE src, SynInf
 \ENSURE  fixed\_code
  \STATE $fixed\_code \gets src$
  \STATE $queue \gets \{0,1,...,|SynInf|-1\}$
  \STATE $flag = 0$
  \WHILE {$|queue| \ne 0 $ and $flag \ne |queue| $}
   \STATE $err\_id \gets queue.pop$
   \STATE $err\_inf \gets SynInf[err\_id]$
   \REPEAT
    \STATE $cur\_patches \gets \textbf{Synthesizer}(err\_inf)$
    \IF {$cur\_patches$ $same$ $as$ $last$ $time$}
     \STATE $\textbf{break}$
    \ENDIF
    \STATE $cur\_code \gets \textbf{Fix}(cur\_patches,fixed\_code)$
    \IF {$not$ $fixed$}
     \STATE $err\_inf \gets \textbf{Update}(err\_inf)$
    \ENDIF
   \UNTIL {$timeout$ or $error$ $fixed$}
   \IF {$current$ $error$ $fixed$}
    \STATE $fixed\_code \gets cur\_code$
    \STATE $flag \gets 0$
    \IF {$queue$ $is$ $not$ $empty$}
     \STATE $SynInf \gets \textbf{Clean}(SynInf)$
     \STATE $SynInf \gets \textbf{Update}(SynInf)$
    \ENDIF
   \ELSE
    \STATE $queue.add(err\_id)$
    \STATE $flag \gets flag + 1$
   \ENDIF
  \ENDWHILE  
 \end{algorithmic} 
 \end{algorithm}

 \begin{algorithm}
 \caption{Function Fix}
 \label{fix}
 \begin{algorithmic}[1]
 \renewcommand{\algorithmicrequire}{\textbf{Input:}}
 \renewcommand{\algorithmicensure}{\textbf{Output:}}
 \REQUIRE cur\_patches, code
 \ENSURE  fixed\_code
  \STATE $test\_code \gets code$
  \FOR {$(cur\_patch,Ret) \in cur\_patches$}
   \FOR {$retloc \in Ret$}
    \STATE $test\_code \gets \textbf{InsertPatch}((cur\_patch,retloc))$
    \STATE $\textbf{Fuzz}(test\_code)$
    \IF {$new$ $error$ $occurs$}
     \STATE $test\_code \gets code$
     \STATE $\textbf{continue}$
    \ELSIF {$same$ $error$ $occurs$}
     \STATE $\textbf{continue}$
    \ELSE 
     \STATE $\textbf{return}$ $test\_code$
    \ENDIF
   \ENDFOR
  \ENDFOR
  \STATE $\textbf{return}$ $\emptyset$


 \end{algorithmic} 
 \end{algorithm}



%----------------------------------------------------------------------------------------
%	Evaluation
%----------------------------------------------------------------------------------------
\section{Evaluation}

%---------------------------------------------------------------------------------------
%      Related work
%----------------------------------------------------------------------------------------
\section{Related Work}
CPR~\cite{CPR}, Angelix~\cite{Angelix}, Extractfix~\cite{Extractfix}, Getafix~\cite{Getafix}, SAVER~\cite{SAVER}, Memfix~\cite{Memfix}


%---------------------------------------------------------------------------------------
%      Conclusion	
%----------------------------------------------------------------------------------------
\section{Conclusion}


%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------

\def\newblock{\hskip .11em plus .33em minus .07em}
\bibliographystyle{plain}
\bibliography{mybib}

%----------------------------------------------------------------------------------------

\end{document}
