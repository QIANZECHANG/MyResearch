%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Journal Article
% LaTeX Template
% Version 1.4 (15/5/16)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com) with extensive modifications by
% Vel (vel@LaTeXTemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[twoside,twocolumn,a4j,dvipdfmx]{article}

%\usepackage{blindtext} % Package to generate dummy text throughout this template 

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage[english]{babel} % Language hyphenation and typographical rules

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text

\usepackage{enumitem} % Customized lists
\setlist[itemize]{noitemsep} % Make itemize lists more compact

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
\renewcommand\thesubsection{\roman{subsection}} % roman numerals for subsections
\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
%\pagestyle{fancy} % All pages have headers and footers
%\fancyhead{} % Blank out the default header
%\fancyfoot{} % Blank out the default footer
%\fancyhead[C]{Running title $\bullet$ May 2016 $\bullet$ Vol. XXI, No. 1} % Custom header text
%\fancyfoot[RO,LE]{\thepage} % Custom footer text

\usepackage{titling} % Customizing the title section
\usepackage[dvipdfmx]{color}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric,arrows,positioning}
\usepackage{hyperref} % For hyperlinks in the PDF
\usepackage{color}
\usepackage{caption,subcaption}
\usepackage{amsmath}
%--------------------------------------------
% code style
%---------------------------------------------
%\usepackage{lstlinebgrd}
\usepackage{xcolor}
\usepackage{listings}
\renewcommand\lstlistingname{Figure}
\renewcommand\lstlistlistingname{Figures}

% Color
\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}
\definecolor{Blue}{HTML}{2d5ae0}
\definecolor{Orange}{HTML}{e33900}
\definecolor{Green}{HTML}{009e73}
\definecolor{Purple}{HTML}{9400d3}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    frame=single,
    framexleftmargin=1em,
    %xleftmargin=0.5em,
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}

%----------------------------------------------
%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\setlength{\droptitle}{-4\baselineskip} % Move the title up

\pretitle{\begin{center}\Huge\bfseries} % Article title formatting
\posttitle{\end{center}} % Article title closing formatting
\title{Automated Memory Error Repair Based on Hybrid Program Analysis} % Article title
\author{ ZECHANG QIAN \\ (Supervisor:  Katsuhiko Gondow)}
%\textsc{John Smith}\thanks{A thank you or further information} \\[1ex] % Your name
%\normalsize University of California \\ % Your institution
%\normalsize \href{mailto:john@smith.com}{john@smith.com} % Your email address
%\and % Uncomment if 2 authors are required, duplicate these 4 lines if more
%\textsc{Jane Smith}\thanks{Corresponding author} \\[1ex] % Second author's name
%\normalsize University of Utah \\ % Second author's institution
%\normalsize \href{mailto:jane@smith.com}{jane@smith.com} % Second author's email address

\date{} % Leave empty to omit a date
\renewcommand{\maketitlehookd}{%
\begin{abstract}
\textcolor{red}{
Automated program repair is a technology which aims to fix program errors and vulnerabilities automatically. In the field of memory error repair, with the development of bug detection tools, we can easily detect memory errors in programs. However, fixing those errors is time-consuming and error-prone. Because the programâ€™s heap-related behavior plays a critical role in memory error repair, the existing techniques are mainly based on static analysis, where the static bug-finder is used to detect program memory errors and then repair tools collect the essential information via static analysis. But since static bug-finder may give wrong alarms which will affect the performance of the repair tools, and static analysis often requires high overhead. }

\textcolor{red}{
We present \textbf{HAMER}, a hybrid automatic memory error repair tool that aims to address those 
shortcomings by using hybrid analysis. HAMER first uses fuzzer to check the alarms given by the static 
bug-finder and extracts the real errors from those alarms. Then it tries to fix those errors by using 
hybrid analysis.}
\end{abstract}
}

%----------------------------------------------------------------------------------------

\begin{document}

% Print the title
\maketitle

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\section{Introduction}
\textcolor{red}{
Memory errors, such as memory leaks, can have catastrophic effects,  thus detecting and fixing them has always been a critical task for developers. Memory error detection performance is improving with the development of memory error detection technologies, however resolving these problems takes a lot of time and work for developers, and erroneous patches might lead to more significant effects.}

\textcolor{red}{
Existing memory error repair techniques\cite{SAVER,Memfix} are mainly based on static analysis. This is because resolving issues like memory leaks necessitates an understanding of heap-related behavior, such as error source and sink. On the other hand, static analysis techniques might have a high time and space overhead, and they aren't always particularly good at dealing with problems such as indirect calls and alias. While dynamic analysis can help with these issues, it does not provide enough information to generate patches.}

\textcolor{red}{
In this paper, we present \textbf{HAMER}, a hybrid analysis-based memory error repair \mbox{technique}. We use a static bug-finder to detect the program first, then use a fuzzer to detect the alarms and extract the real bugs. After that, we collect program variables that can be utilized to synthesize patches by variable dependency analysis. We also gather the test cases generated by the fuzzer which trigger or do not trigger the errors and then use the component-based program synthesis technique to try to generate patches from these variables and test cases. Finally, We utilize a fuzzer to detect the current fixed program, and if the repair is erroneous, we collect the test case that triggers the errors and repeat our repair method until the error is resolved or timeout. This strategy ensures that the patches generated by HAMER can repair current errors while without introducing new ones.}

\textcolor{red}{
\textbf{Contributions.} This paper makes the following contributions:
\begin{itemize}
  \item We present a new technique for repairing memory errors based on hybrid analysis.
  \item We present HAMER~\footnote{https://github.com/QIANZECHANG/MyResearch}, a memory error repair tool that implements the proposed approach.
\end{itemize}
}

%------------------------------------------------
%	Overview
%----------------------------------------------------------------------------------------

\section{Overview}
%----------------pipeline-----------------------------------
\tikzstyle{tool} = [diamond, draw, fill=green!20, text centered, text width=4.5em, aspect=2]
\tikzstyle{block} = [rectangle, draw, fill=blue!20, text width=7em, rounded corners, minimum height=3em]
\tikzstyle{bigblock} = [rectangle, draw, fill=blue!20, text width=9em, rounded corners, minimum height=3em]
\tikzstyle{line} = [thick,->,>=stealth]
\tikzstyle{outdata} = [rectangle, draw, fill=brown!20, text width=5em, minimum height=3em]
\tikzstyle{code} = [draw, ellipse,fill=red!20, text width=2em, minimum height=3em]
\tikzstyle{bigcode} = [draw, ellipse,fill=red!20, text width=5.5em, minimum height=3em]
\begin{figure*}[ht]
\begin{tikzpicture}[node distance = 3.5cm, on grid]
  %node
  \node[tool] (infer){Infer};
  \node[code, below of=infer,yshift=1.5cm] (src){src.c};
  \node[outdata, right of=infer] (efunc){error\\functions};
  \node[tool, right of=src] (fuzzer1){LibFuzzer};
  \node[outdata, below of=fuzzer1, yshift=1.5cm] (error){true errors};
  \node[block, below of=error,yshift=2cm] (dep){Dependency\\Collection};
  \node[outdata, right of=dep] (depvar){dependent\\variables};
  \node[block, right of=error,yshift=1cm] (inst){Source\\Instrumentation};
  \node[bigcode, right of=fuzzer1,yshift=1cm] (instcode){Instrumented\\code};
  \node[tool, right of=instcode] (fuzzer2){LibFuzzer};
  \node[outdata, right of=inst] (test){test suite};
  \node[bigblock, right of=depvar] (syn){Component-based\\Program Synthesis};
  \node[bigcode, right of=syn] (fix){current\\fixed code};
  \node[code, above of=fuzzer2,yshift=-1.5cm] (output){out.c};
  \node[right of=output,yshift=-1cm,xshift=-2.5cm] (no){no error}; 
  \node[below of=no,yshift=1.5cm,xshift=-0.3cm] (yes){error}; 
 %edge
  \draw [line] (src) -- (infer);
  \draw [line] (src) -- (fuzzer1);
  \draw [line] (infer) -- (efunc);
  \draw [line] (efunc) -- (fuzzer1);
  \draw [line] (fuzzer1) -- (error);
  \draw [line] (error) -- (dep);
  \draw [line] (src) |- (dep);
  \draw [line] (dep) -- (depvar);
  \draw [line] (depvar) -- (inst);
  \draw [line] (inst) -- (instcode);
  \draw [line] (instcode) -- (fuzzer2);
  \draw [line] (fuzzer2) -- (test);
  \draw [line] (test) -- (syn);
  \draw [line] (depvar) -- (syn);
  \draw [line] (syn) -- (fix);
  \draw [line] (fix) |- (fuzzer2);
  \draw [line] (fuzzer2) -- (output);
  \draw [line] (src) |- (inst);
\end{tikzpicture}
  \caption{HAMER pipeline}
  \label{pipeline}
\end{figure*}
%----------------code---------------------------
\lstset{
  style=CStyle,
  moredelim=[is][\color{Blue}\bfseries]{<\#blue\#}{\#>},
  moredelim=[is][\color{Orange}\bfseries]{<\#orange\#}{\#>},
  moredelim=[is][\color{Green}\bfseries]{<\#green\#}{\#>},
  moredelim=[is][\color{Purple}\bfseries]{<\#purple\#}{\#>},
}

\begin{figure*}
  \begin{subfigure}{0.47\textwidth}
    \lstinputlisting{src.c}
    \caption{o0, o1, o2 occur memory leak}
  \end{subfigure}\hfill
  \begin{subfigure}{0.45\textwidth}
    \lstinputlisting[firstline=17,firstnumber=17]{result_src.c}
    \caption{HAMER-generated patch}
  \end{subfigure}
  \caption{Motivating Example 1: False-Negative}
\end{figure*}

\begin{figure*}
  \begin{subfigure}{0.47\textwidth}
    \lstinputlisting{saver.c}
    \caption{No memory leak}
  \end{subfigure}\hfill
  \begin{subfigure}{0.45\textwidth}
    \lstinputlisting{saver_result.c}
    \caption{SAVER-generated patch}
  \end{subfigure}
  \caption{Motivating Example 2: False-Positive}
\end{figure*}

\textcolor{red}{
We illustrate key features of HAMER and how it works. Figure~\ref{pipeline} depicts a high-level overview of the HAMER pipeline. First, we check the program with the static analyzer \mbox{Infer}~\footnote{https://fbinfer.com/}, and then we manually collect the functions that contain Infer alerts. Following that, these functions are fuzzed by LibFuzzer~\footnote{https://llvm.org/docs/LibFuzzer.html} to detect true errors.  For those functions on the error path, we collect the variables that are dependent on the function arguments and stub them, and then we collect the tests that do or do not trigger the error by LibFuzzer. Finally, we use component-based program synthesis to generate patches. Because the quality of the test suite affects the quality of the patch, we use LibFuzzer to check the current fixed code again, and if it hasn't been fixed or if a new error occurs, we collect the tests that cause the error or insert the patch in a different location. This strategy ensures that the patches generated by HAMER are correct and do not introduce new errors. In the following paragraphs of this section, we will use two motivating examples to demonstrate the workflow and characteristics of HAMER.}
\subsection{Motivating Example 1}

\begin{minipage}{15em}
    in malloc (../a.out+0x52204d)\\
    in new\_node1 ../src.c:6:18\\
    in func ../src.c:21:5
\end{minipage}
\subsection{Motivating Example 2}
%-------------code--------------------------------
%[+] { Insert: if (true) free(*(func:x.p2)) at 3 (line 12, column 3) }

%------------------------------------------------------


%---------------------------------------------------------------------------------------
%	Approach
%----------------------------------------------------------------------------------------
\section{Approach}





%----------------------------------------------------------------------------------------
%	Evaluation
%----------------------------------------------------------------------------------------
\section{Evaluation}

%---------------------------------------------------------------------------------------
%      Related work
%----------------------------------------------------------------------------------------
\section{Related Work}


%---------------------------------------------------------------------------------------
%      Conclusion	
%----------------------------------------------------------------------------------------
\section{Conclusion}


%----------------------------------------------------------------------------------------
%	REFERENCE LIST
%----------------------------------------------------------------------------------------

\def\newblock{\hskip .11em plus .33em minus .07em}
\bibliographystyle{plain}
\bibliography{mybib}

%----------------------------------------------------------------------------------------

\end{document}
