@INPROCEEDINGS{SAVER, 
    author=       "Hong, Seongjoon and Lee, Junhee and Lee, Jeongsoo and Oh, Hakjoo",    
    title=        "SAVER: Scalable, Precise, and Safe Memory-Error Repair",   
    booktitle=    "2020 IEEE/ACM 42nd International Conference on Software Engineering (ICSE)", 
    year=         2020,  
    pages=        "271-283"}

@inproceedings{CPR,
author = {Shariffdeen, Ridwan and Noller, Yannic and Grunske, Lars and Roychoudhury, Abhik},
title = {Concolic Program Repair},
year = {2021},
booktitle = {Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
pages = {390–405},
series = {PLDI 2021}
}

@inproceedings{Memfix,
author = {Lee, Junhee and Hong, Seongjoon and Oh, Hakjoo},
title = {MemFix: Static Analysis-Based Repair of Memory Deallocation Errors for C},
year = {2018},
series = {ESEC/FSE 2018}
}

@INPROCEEDINGS{Angelix,  
author={Mechtaev, Sergey and Yi, Jooyong and Roychoudhury, Abhik},  
booktitle={2016 IEEE/ACM 38th International Conference on Software Engineering (ICSE)},   
title={Angelix: Scalable Multiline Program Patch Synthesis via Symbolic Analysis},   
year={2016},  
pages={691-701}}


@article{Extractfix,
author = {Gao, Xiang and Wang, Bo and Duck, Gregory J. and Ji, Ruyi and Xiong, Yingfei and Roychoudhury, Abhik},
title = {Beyond Tests: Program Vulnerability Repair via Crash Constraint Extraction},
year = {2021},
issue_date = {March 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {30},
number = {2},
issn = {1049-331X},
url = {https://doi.org/10.1145/3418461},
doi = {10.1145/3418461},
abstract = {Automated program repair is an emerging technology that seeks to automatically rectify program errors and vulnerabilities. Repair techniques are driven by a correctness criterion that is often in the form of a test suite. Such test-based repair may produce overfitting patches, where the patches produced fail on tests outside the test suite driving the repair. In this work, we present a repair method that fixes program vulnerabilities without the need for a voluminous test suite. Given a vulnerability as evidenced by an exploit, the technique extracts a constraint representing the vulnerability with the help of sanitizers. The extracted constraint serves as a proof obligation that our synthesized patch should satisfy. The proof obligation is met by propagating the extracted constraint to locations that are deemed to be “suitable” fix locations. An implementation of our approach (ExtractFix) on top of the KLEE symbolic execution engine shows its efficacy in fixing a wide range of vulnerabilities taken from the ManyBugs benchmark, real-world CVEs and Google’s OSS-Fuzz framework. We believe that our work presents a way forward for the overfitting problem in program repair by generalizing observable hazards/vulnerabilities (as constraint) from a single failing test or exploit.},
journal = {ACM Trans. Softw. Eng. Methodol.},
month = {feb},
articleno = {14},
numpages = {27},
keywords = {overfitting, constraint extraction and propagation, Automated program repair}
}

@article{Getafix,
author = {Bader, Johannes and Scott, Andrew and Pradel, Michael and Chandra, Satish},
title = {Getafix: Learning to Fix Bugs Automatically},
year = {2019},
issue_date = {October 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {OOPSLA},
url = {https://doi.org/10.1145/3360585},
doi = {10.1145/3360585},
abstract = {Static analyzers help find bugs early by warning about recurring bug categories. While fixing these bugs still remains a mostly manual task in practice, we observe that fixes for a specific bug category often are repetitive. This paper addresses the problem of automatically fixing instances of common bugs by learning from past fixes. We present Getafix, an approach that produces human-like fixes while being fast enough to suggest fixes in time proportional to the amount of time needed to obtain static analysis results in the first place.  Getafix is based on a novel hierarchical clustering algorithm that summarizes fix patterns into a hierarchy ranging from general to specific patterns. Instead of an expensive exploration of a potentially large space of candidate fixes, Getafix uses a simple yet effective ranking technique that uses the context of a code change to select the most appropriate fix for a given bug.  Our evaluation applies Getafix to 1,268 bug fixes for six bug categories reported by popular static analyzers for Java, including null dereferences, incorrect API calls, and misuses of particular language constructs. The approach predicts exactly the human-written fix as the top-most suggestion between 12% and 91% of the time, depending on the bug category. The top-5 suggestions contain fixes for 526 of the 1,268 bugs. Moreover, we report on deploying the approach within Facebook, where it contributes to the reliability of software used by billions of people. To the best of our knowledge, Getafix is the first industrially-deployed automated bug-fixing tool that learns fix patterns from past, human-written fixes to produce human-like fixes.},
journal = {Proc. ACM Program. Lang.},
month = {oct},
articleno = {159},
numpages = {27},
keywords = {Patch generation, Code transform, Automated program repair}
}

@inproceedings{oracle,
author = {Jha, Susmit and Gulwani, Sumit and Seshia, Sanjit A. and Tiwari, Ashish},
title = {Oracle-Guided Component-Based Program Synthesis},
year = {2010},
isbn = {9781605587196},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1806799.1806833},
doi = {10.1145/1806799.1806833},
abstract = {We present a novel approach to automatic synthesis of loop-free programs. The approach is based on a combination of oracle-guided learning from examples, and constraint-based synthesis from components using satisfiability modulo theories (SMT) solvers. Our approach is suitable for many applications, including as an aid to program understanding tasks such as deobfuscating malware. We demonstrate the efficiency and effectiveness of our approach by synthesizing bit-manipulating programs and by deobfuscating programs.},
booktitle = {Proceedings of the 32nd ACM/IEEE International Conference on Software Engineering - Volume 1},
pages = {215–224},
numpages = {10},
keywords = {oracle-based learning, SMT, SAT, program synthesis},
location = {Cape Town, South Africa},
series = {ICSE '10}
}

@inproceedings{z3,
  author    = {Leonardo Mendon{\c{c}}a de Moura and
               Nikolaj Bj{\o}rner},
  editor    = {C. R. Ramakrishnan and
               Jakob Rehof},
  title     = {{Z3:} An Efficient {SMT} Solver},
  booktitle = {Tools and Algorithms for the Construction and Analysis of Systems,
               14th International Conference, {TACAS} 2008, Held as Part of the Joint
               European Conferences on Theory and Practice of Software, {ETAPS} 2008,
               Budapest, Hungary, March 29-April 6, 2008. Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {4963},
  pages     = {337--340},
  publisher = {Springer},
  year      = {2008},
  url       = {https://doi.org/10.1007/978-3-540-78800-3\_24},
  doi       = {10.1007/978-3-540-78800-3\_24},
  timestamp = {Tue, 14 May 2019 10:00:53 +0200},
  biburl    = {https://dblp.org/rec/conf/tacas/MouraB08.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings {asan,
author = {Konstantin Serebryany and Derek Bruening and Alexander Potapenko and Dmitriy Vyukov},
title = {{AddressSanitizer}: A Fast Address Sanity Checker},
booktitle = {2012 USENIX Annual Technical Conference (USENIX ATC 12)},
year = {2012},
isbn = {978-931971-93-5},
address = {Boston, MA},
pages = {309--318},
url = {https://www.usenix.org/conference/atc12/technical-sessions/presentation/serebryany},
publisher = {USENIX Association},
month = jun,
}

@InProceedings{infer,
author="Calcagno, Cristiano
and Distefano, Dino",
editor="Bobaru, Mihaela
and Havelund, Klaus
and Holzmann, Gerard J.
and Joshi, Rajeev",
title="Infer: An Automatic Program Verifier for Memory Safety of C Programs",
booktitle="NASA Formal Methods",
year="2011",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="459--465",
abstract="Infer is a new automatic program verification tool aimed at proving memory safety of C programs. It attempts to build a compositional proof of the program at hand by composing proofs of its constituent modules (functions/procedures). Bugs are extracted from failures of proof attempts. We describe the main features of Infer and some of the main ideas behind it.",
isbn="978-3-642-20398-5"
}
