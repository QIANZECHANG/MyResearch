@INPROCEEDINGS{SAVER, 
    author=       "Hong, Seongjoon and Lee, Junhee and Lee, Jeongsoo and Oh, Hakjoo",    
    title=        "SAVER: Scalable, Precise, and Safe Memory-Error Repair",   
    booktitle=    "2020 IEEE/ACM 42nd International Conference on Software Engineering (ICSE)", 
    year=         2020,  
    pages=        "271-283"}

@inproceedings{CPR,
author = {Shariffdeen, Ridwan and Noller, Yannic and Grunske, Lars and Roychoudhury, Abhik},
title = {Concolic Program Repair},
year = {2021},
booktitle = {Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
pages = {390–405},
series = {PLDI 2021}
}

@inproceedings{Memfix,
author = {Lee, Junhee and Hong, Seongjoon and Oh, Hakjoo},
title = {MemFix: Static Analysis-Based Repair of Memory Deallocation Errors for C},
year = {2018},
series = {ESEC/FSE 2018}
}

@INPROCEEDINGS{Angelix,  
author={Mechtaev, Sergey and Yi, Jooyong and Roychoudhury, Abhik},  
booktitle={2016 IEEE/ACM 38th International Conference on Software Engineering (ICSE)},   
title={Angelix: Scalable Multiline Program Patch Synthesis via Symbolic Analysis},   
year={2016},  
pages={691-701}}


@article{Extractfix,
author = {Gao, Xiang and Wang, Bo and Duck, Gregory J. and Ji, Ruyi and Xiong, Yingfei and Roychoudhury, Abhik},
title = {Beyond Tests: Program Vulnerability Repair via Crash Constraint Extraction},
year = {2021},
issue_date = {March 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {30},
number = {2},
issn = {1049-331X},
url = {https://doi.org/10.1145/3418461},
doi = {10.1145/3418461},
abstract = {Automated program repair is an emerging technology that seeks to automatically rectify program errors and vulnerabilities. Repair techniques are driven by a correctness criterion that is often in the form of a test suite. Such test-based repair may produce overfitting patches, where the patches produced fail on tests outside the test suite driving the repair. In this work, we present a repair method that fixes program vulnerabilities without the need for a voluminous test suite. Given a vulnerability as evidenced by an exploit, the technique extracts a constraint representing the vulnerability with the help of sanitizers. The extracted constraint serves as a proof obligation that our synthesized patch should satisfy. The proof obligation is met by propagating the extracted constraint to locations that are deemed to be “suitable” fix locations. An implementation of our approach (ExtractFix) on top of the KLEE symbolic execution engine shows its efficacy in fixing a wide range of vulnerabilities taken from the ManyBugs benchmark, real-world CVEs and Google’s OSS-Fuzz framework. We believe that our work presents a way forward for the overfitting problem in program repair by generalizing observable hazards/vulnerabilities (as constraint) from a single failing test or exploit.},
journal = {ACM Trans. Softw. Eng. Methodol.},
month = {feb},
articleno = {14},
numpages = {27},
keywords = {overfitting, constraint extraction and propagation, Automated program repair}
}

@article{Getafix,
author = {Bader, Johannes and Scott, Andrew and Pradel, Michael and Chandra, Satish},
title = {Getafix: Learning to Fix Bugs Automatically},
year = {2019},
issue_date = {October 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {OOPSLA},
url = {https://doi.org/10.1145/3360585},
doi = {10.1145/3360585},
abstract = {Static analyzers help find bugs early by warning about recurring bug categories. While fixing these bugs still remains a mostly manual task in practice, we observe that fixes for a specific bug category often are repetitive. This paper addresses the problem of automatically fixing instances of common bugs by learning from past fixes. We present Getafix, an approach that produces human-like fixes while being fast enough to suggest fixes in time proportional to the amount of time needed to obtain static analysis results in the first place.  Getafix is based on a novel hierarchical clustering algorithm that summarizes fix patterns into a hierarchy ranging from general to specific patterns. Instead of an expensive exploration of a potentially large space of candidate fixes, Getafix uses a simple yet effective ranking technique that uses the context of a code change to select the most appropriate fix for a given bug.  Our evaluation applies Getafix to 1,268 bug fixes for six bug categories reported by popular static analyzers for Java, including null dereferences, incorrect API calls, and misuses of particular language constructs. The approach predicts exactly the human-written fix as the top-most suggestion between 12% and 91% of the time, depending on the bug category. The top-5 suggestions contain fixes for 526 of the 1,268 bugs. Moreover, we report on deploying the approach within Facebook, where it contributes to the reliability of software used by billions of people. To the best of our knowledge, Getafix is the first industrially-deployed automated bug-fixing tool that learns fix patterns from past, human-written fixes to produce human-like fixes.},
journal = {Proc. ACM Program. Lang.},
month = {oct},
articleno = {159},
numpages = {27},
keywords = {Patch generation, Code transform, Automated program repair}
}

@inproceedings{oracle,
author = {Jha, Susmit and Gulwani, Sumit and Seshia, Sanjit A. and Tiwari, Ashish},
title = {Oracle-Guided Component-Based Program Synthesis},
year = {2010},
isbn = {9781605587196},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1806799.1806833},
doi = {10.1145/1806799.1806833},
abstract = {We present a novel approach to automatic synthesis of loop-free programs. The approach is based on a combination of oracle-guided learning from examples, and constraint-based synthesis from components using satisfiability modulo theories (SMT) solvers. Our approach is suitable for many applications, including as an aid to program understanding tasks such as deobfuscating malware. We demonstrate the efficiency and effectiveness of our approach by synthesizing bit-manipulating programs and by deobfuscating programs.},
booktitle = {Proceedings of the 32nd ACM/IEEE International Conference on Software Engineering - Volume 1},
pages = {215–224},
numpages = {10},
keywords = {oracle-based learning, SMT, SAT, program synthesis},
location = {Cape Town, South Africa},
series = {ICSE '10}
}

@inproceedings{z3,
  author    = {Leonardo Mendon{\c{c}}a de Moura and
               Nikolaj Bj{\o}rner},
  editor    = {C. R. Ramakrishnan and
               Jakob Rehof},
  title     = {{Z3:} An Efficient {SMT} Solver},
  booktitle = {Tools and Algorithms for the Construction and Analysis of Systems,
               14th International Conference, {TACAS} 2008, Held as Part of the Joint
               European Conferences on Theory and Practice of Software, {ETAPS} 2008,
               Budapest, Hungary, March 29-April 6, 2008. Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {4963},
  pages     = {337--340},
  publisher = {Springer},
  year      = {2008},
  url       = {https://doi.org/10.1007/978-3-540-78800-3\_24},
  doi       = {10.1007/978-3-540-78800-3\_24},
  timestamp = {Tue, 14 May 2019 10:00:53 +0200},
  biburl    = {https://dblp.org/rec/conf/tacas/MouraB08.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings {asan,
author = {Konstantin Serebryany and Derek Bruening and Alexander Potapenko and Dmitriy Vyukov},
title = {{AddressSanitizer}: A Fast Address Sanity Checker},
booktitle = {2012 USENIX Annual Technical Conference (USENIX ATC 12)},
year = {2012},
isbn = {978-931971-93-5},
address = {Boston, MA},
pages = {309--318},
url = {https://www.usenix.org/conference/atc12/technical-sessions/presentation/serebryany},
publisher = {USENIX Association},
month = jun,
}

@InProceedings{infer,
author="Calcagno, Cristiano
and Distefano, Dino",
editor="Bobaru, Mihaela
and Havelund, Klaus
and Holzmann, Gerard J.
and Joshi, Rajeev",
title="Infer: An Automatic Program Verifier for Memory Safety of C Programs",
booktitle="NASA Formal Methods",
year="2011",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="459--465",
abstract="Infer is a new automatic program verification tool aimed at proving memory safety of C programs. It attempts to build a compositional proof of the program at hand by composing proofs of its constituent modules (functions/procedures). Bugs are extracted from failures of proof attempts. We describe the main features of Infer and some of the main ideas behind it.",
isbn="978-3-642-20398-5"
}

@INPROCEEDINGS{semfix,
  author={Nguyen, Hoang Duong Thien and Qi, Dawei and Roychoudhury, Abhik and Chandra, Satish},
  booktitle={2013 35th International Conference on Software Engineering (ICSE)}, 
  title={SemFix: Program repair via semantic analysis}, 
  year={2013},
  volume={},
  number={},
  pages={772-781},
  doi={10.1109/ICSE.2013.6606623}}

@INPROCEEDINGS{directfix,
  author={Mechtaev, Sergey and Yi, Jooyong and Roychoudhury, Abhik},
  booktitle={2015 IEEE/ACM 37th IEEE International Conference on Software Engineering}, 
  title={DirectFix: Looking for Simple Program Repairs}, 
  year={2015},
  volume={1},
  number={},
  pages={448-458},
  doi={10.1109/ICSE.2015.63}}

@article{10.1145/1449955.1449774,
author = {Bond, Michael D. and McKinley, Kathryn S.},
title = {Tolerating Memory Leaks},
year = {2008},
issue_date = {September 2008},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {43},
number = {10},
issn = {0362-1340},
url = {https://doi.org/10.1145/1449955.1449774},
doi = {10.1145/1449955.1449774},
abstract = {Type safety and garbage collection in managed languages eliminate memory errors such as dangling pointers, double frees, and leaks of unreachable objects. Unfortunately, a program still leaks memory if it maintains references to objects it will never use again. Leaked objects decrease program locality and increase garbage collection frequency and workload. A growing leak will eventually exhaust memory and crash the program.This paper introduces a leak tolerance approach called Melt that safely eliminates performance degradations and crashes due to leaks of dead but reachable objects in managed languages, given sufficient disk space to hold leaking objects. Melt (1) identifies stale objects that the program is not accessing; (2) segregates in-use and stale objects by storing stale objects to disk; and (3) preserves safety by activating stale objects if the program subsequently accesses them. We design and build a prototype implementation of Melt in a Java VM and show it adds overhead low enough for production systems. Whereas existing VMs grind to a halt and then crash on programs with leaks, Melt keeps many of these programs running much longer without significantly degrading performance. Melt provides users the illusion of a fixed leak and gives developers more time to fix leaky programs.},
journal = {SIGPLAN Not.},
month = {oct},
pages = {109–126},
numpages = {18},
keywords = {managed languages, memory leaks, bug tolerance}
}


@inproceedings{melt,
author = {Bond, Michael D. and McKinley, Kathryn S.},
title = {Tolerating Memory Leaks},
year = {2008},
isbn = {9781605582153},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1449764.1449774},
doi = {10.1145/1449764.1449774},
booktitle = {Proceedings of the 23rd ACM SIGPLAN Conference on Object-Oriented Programming Systems Languages and Applications},
pages = {109–126},
numpages = {18},
keywords = {bug tolerance, managed languages, memory leaks},
location = {Nashville, TN, USA},
series = {OOPSLA '08}
}

@INPROCEEDINGS{leakpoint,
  author={Clause, James and Orso, Alessandro},
  booktitle={2010 ACM/IEEE 32nd International Conference on Software Engineering}, 
  title={LEAKPOINT: pinpointing the causes of memory leaks}, 
  year={2010},
  volume={1},
  number={},
  pages={515-524},
  doi={10.1145/1806799.1806874}}

@INPROCEEDINGS{leakfix,
  author={Gao, Qing and Xiong, Yingfei and Mi, Yaqing and Zhang, Lu and Yang, Weikun and Zhou, Zhaoping and Xie, Bing and Mei, Hong},
  booktitle={2015 IEEE/ACM 37th IEEE International Conference on Software Engineering}, 
  title={Safe Memory-Leak Fixing for C Programs}, 
  year={2015},
  volume={1},
  number={},
  pages={459-470},
  doi={10.1109/ICSE.2015.64}}

@ARTICLE{survey,
  author={Gazzola, Luca and Micucci, Daniela and Mariani, Leonardo},
  journal={IEEE Transactions on Software Engineering}, 
  title={Automatic Software Repair: A Survey}, 
  year={2019},
  volume={45},
  number={1},
  pages={34-67},
  doi={10.1109/TSE.2017.2755013}}

@inproceedings{ownership,
author = {Rayside, Derek and Mendel, Lucy},
title = {Object Ownership Profiling: A Technique for Finding and Fixing Memory Leaks},
year = {2007},
isbn = {9781595938824},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1321631.1321661},
doi = {10.1145/1321631.1321661},
booktitle = {Proceedings of the Twenty-Second IEEE/ACM International Conference on Automated Software Engineering},
pages = {194–203},
numpages = {10},
keywords = {java, memory leaks, object ownership},
location = {Atlanta, Georgia, USA},
series = {ASE '07}
}

@inproceedings{transfor,
  title={Automatic Memory Management Based on Program Transformation Using Ownership},
  author={Tatsuya Sonobe and Kohei Suenaga and Atsushi Igarashi},
  booktitle={APLAS},
  year={2014}
}

@inproceedings{10.1145/2384616.2384618,
author = {Suenaga, Kohei and Fukuda, Ryota and Igarashi, Atsushi},
title = {Type-Based Safe Resource Deallocation for Shared-Memory Concurrency},
year = {2012},
isbn = {9781450315616},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2384616.2384618},
doi = {10.1145/2384616.2384618},
abstract = {We propose a type system to guarantee safe resource deallocation for shared-memory concurrent programs by extending the previous type system based on fractional ownerships. Here, safe resource deallocation means that memory cells, locks, or threads are not left allocated when a program terminates. Our framework supports (1) fork/join parallelism, (2) synchronization with locks, and (3) dynamically allocated memory cells and locks. The type system is proved to be sound. We also provide a type inference algorithm for the type system and a prototype implementation of the algorithm.},
booktitle = {Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications},
pages = {1–20},
numpages = {20},
keywords = {type inference, race freedom, type systems, safe resource deallocation, fractional ownerships, shared-memory concurrency, memory leak, SMT solver, fork/join parallelism},
location = {Tucson, Arizona, USA},
series = {OOPSLA '12}
}


@article{typebase,
author = {Suenaga, Kohei and Fukuda, Ryota and Igarashi, Atsushi},
title = {Type-Based Safe Resource Deallocation for Shared-Memory Concurrency},
year = {2012},
issue_date = {October 2012},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {47},
number = {10},
issn = {0362-1340},
url = {https://doi.org/10.1145/2398857.2384618},
doi = {10.1145/2398857.2384618},
journal = {SIGPLAN Not.},
month = {oct},
pages = {1–20},
numpages = {20},
keywords = {safe resource deallocation, shared-memory concurrency, SMT solver, type inference, fork/join parallelism, type systems, fractional ownerships, memory leak, race freedom}
}

@InProceedings{fractional,
author="Suenaga, Kohei
and Kobayashi, Naoki",
editor="Hu, Zhenjiang",
title="Fractional Ownerships for Safe Memory Deallocation",
booktitle="Programming Languages and Systems",
year="2009",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="128--143",
abstract="We propose a type system for a programming language with memory allocation/deallocation primitives, which prevents memory- related errors such as double-frees and memory leaks. The main idea is to augment pointer types with fractional ownerships, which express both capabilities and obligations to access or deallocate memory cells. By assigning an ownership to each pointer type constructor (rather than to a variable), our type system can properly reason about list/tree-manipulating programs. Furthermore, thanks to the use of fractions as ownerships, the type system admits a polynomial-time type inference algorithm, which serves as an algorithm for automatic verification of lack of memory-related errors. A prototype verifier has been implemented and tested for C programs.",
isbn="978-3-642-10672-9"
}

@inproceedings{footpatch,
author = {van Tonder, Rijnard and Goues, Claire Le},
title = {Static Automated Program Repair for Heap Properties},
year = {2018},
isbn = {9781450356381},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3180155.3180250},
doi = {10.1145/3180155.3180250},
booktitle = {Proceedings of the 40th International Conference on Software Engineering},
pages = {151–162},
numpages = {12},
keywords = {separation logic, automated program repair},
location = {Gothenburg, Sweden},
series = {ICSE '18}
}

@article{leakchaser,
author = {Xu, Guoqing and Bond, Michael D. and Qin, Feng and Rountev, Atanas},
title = {LeakChaser: Helping Programmers Narrow down Causes of Memory Leaks},
year = {2011},
issue_date = {June 2011},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {46},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/1993316.1993530},
doi = {10.1145/1993316.1993530},
journal = {SIGPLAN Not.},
month = {jun},
pages = {270–282},
numpages = {13},
keywords = {object lifetime assertions, memory leak detection, leakchaser}
}

@article{defleak,
  title={A dynamic approach to detecting, eliminating and fixing memory leaks},
  author={Bin Yu and Cong Tian and Nan Zhang and Zhenhua Duan and Hongwei Du},
  journal={Journal of Combinatorial Optimization},
  year={2021},
  pages={1-18}
}

@inproceedings{par,
author = {Kim, Dongsun and Nam, Jaechang and Song, Jaewoo and Kim, Sunghun},
title = {Automatic Patch Generation Learned from Human-Written Patches},
year = {2013},
isbn = {9781467330763},
publisher = {IEEE Press},
booktitle = {Proceedings of the 2013 International Conference on Software Engineering},
pages = {802–811},
numpages = {10},
location = {San Francisco, CA, USA},
series = {ICSE '13}
}

@inproceedings{jfix,
author = {Le, Xuan-Bach D. and Chu, Duc-Hiep and Lo, David and Le Goues, Claire and Visser, Willem},
title = {JFIX: Semantics-Based Repair of Java Programs via Symbolic PathFinder},
year = {2017},
isbn = {9781450350761},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3092703.3098225},
doi = {10.1145/3092703.3098225},
booktitle = {Proceedings of the 26th ACM SIGSOFT International Symposium on Software Testing and Analysis},
pages = {376–379},
numpages = {4},
keywords = {Symbolic Execution, Automatic Program Repair, Program Synthesis},
location = {Santa Barbara, CA, USA},
series = {ISSTA 2017}
}

@inproceedings{s3,
author = {Le, Xuan-Bach D. and Chu, Duc-Hiep and Lo, David and Le Goues, Claire and Visser, Willem},
title = {S3: Syntax- and Semantic-Guided Repair Synthesis via Programming by Examples},
year = {2017},
isbn = {9781450351058},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3106237.3106309},
doi = {10.1145/3106237.3106309},
booktitle = {Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering},
pages = {593–604},
numpages = {12},
keywords = {Programming by Examples, Program Repair, Symbolic Execution, Inductive Synthesis},
location = {Paderborn, Germany},
series = {ESEC/FSE 2017}
}

@inproceedings{spr,
author = {Long, Fan and Rinard, Martin},
title = {Staged Program Repair with Condition Synthesis},
year = {2015},
isbn = {9781450336758},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2786805.2786811},
doi = {10.1145/2786805.2786811},
booktitle = {Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering},
pages = {166–178},
numpages = {13},
keywords = {Staged repair, Program repair, Condition synthesis},
location = {Bergamo, Italy},
series = {ESEC/FSE 2015}
}


@article{prophet,
author = {Long, Fan and Rinard, Martin},
title = {Automatic Patch Generation by Learning Correct Code},
year = {2016},
issue_date = {January 2016},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {51},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/2914770.2837617},
doi = {10.1145/2914770.2837617},
journal = {SIGPLAN Not.},
month = {jan},
pages = {298–312},
numpages = {15},
keywords = {Program repair, Learning correct code, Code correctness model}
}

@inproceedings{cp,
author = {Sidiroglou-Douskos, Stelios and Lahtinen, Eric and Long, Fan and Rinard, Martin},
title = {Automatic Error Elimination by Horizontal Code Transfer across Multiple Applications},
year = {2015},
isbn = {9781450334686},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2737924.2737988},
doi = {10.1145/2737924.2737988},
abstract = { We present Code Phage (CP), a system for automatically transferring correct code from donor applications into recipient applications that process the same inputs to successfully eliminate errors in the recipient. Experimental results using seven donor applications to eliminate ten errors in seven recipient applications highlight the ability of CP to transfer code across applications to eliminate out of bounds access, integer overflow, and divide by zero errors. Because CP works with binary donors with no need for source code or symbolic information, it supports a wide range of use cases. To the best of our knowledge, CP is the first system to automatically transfer code across multiple applications. },
booktitle = {Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {43–54},
numpages = {12},
keywords = {data structure translation, program repair, automatic code transfer},
location = {Portland, OR, USA},
series = {PLDI '15}
}

@INPROCEEDINGS{acs,
  author={Xiong, Yingfei and Wang, Jie and Yan, Runfa and Zhang, Jiachen and Han, Shi and Huang, Gang and Zhang, Lu},
  booktitle={2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)}, 
  title={Precise Condition Synthesis for Program Repair}, 
  year={2017},
  volume={},
  number={},
  pages={416-426},
  doi={10.1109/ICSE.2017.45}}

@INPROCEEDINGS{buffer,
  author={Shaw, Alex and Doggett, Dusten and Hafiz, Munawar},
  booktitle={2014 44th Annual IEEE/IFIP International Conference on Dependable Systems and Networks}, 
  title={Automatically Fixing C Buffer Overflows Using Program Transformations}, 
  year={2014},
  volume={},
  number={},
  pages={124-135},
  doi={10.1109/DSN.2014.25}}

@INPROCEEDINGS{npe,
  author={Durieux, Thomas and Cornu, Benoit and Seinturier, Lionel and Monperrus, Martin},
  booktitle={2017 IEEE 24th International Conference on Software Analysis, Evolution and Reengineering (SANER)}, 
  title={Dynamic patch generation for null pointer exceptions using metaprogramming}, 
  year={2017},
  volume={},
  number={},
  pages={349-358},
  doi={10.1109/SANER.2017.7884635}}

@article{bi,
author = {Calcagno, Cristiano and Distefano, Dino and O’Hearn, Peter W. and Yang, Hongseok},
title = {Compositional Shape Analysis by Means of Bi-Abduction},
year = {2011},
issue_date = {December 2011},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {58},
number = {6},
issn = {0004-5411},
url = {https://doi.org/10.1145/2049697.2049700},
doi = {10.1145/2049697.2049700},
journal = {J. ACM},
month = {dec},
articleno = {26},
numpages = {66},
keywords = {compositionality, program proving, Abstract interpretation, separation logic, static analysis}
}